# auto_impl_trait

```rust
#[auto_impl(image)]
pub struct Square {
    side: i32,
}
```

Will expand to

```rust
#[doc = "Generated by `#[derive(auto_impl(image))]`"]
pub struct Square {
    side: i32,
}
#[doc = "Version v1 impls generated by auto_impl"]
pub mod v1 {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionRequest {
        #[doc = " Version of the kubelet runtime API."]
        #[prost(string, tag = "1")] pub version: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionResponse {
        #[doc = " Version of the kubelet runtime API."]
        #[prost(string, tag = "1")] pub version: ::prost::alloc::string::String,
        #[doc = " Name of the container runtime."]
        #[prost(string, tag = "2")] pub runtime_name: ::prost::alloc::string::String,
        #[doc = " Version of the container runtime. The string must be"]
        #[doc = " semver-compatible."]
        #[prost(string, tag = "3")] pub runtime_version: ::prost::alloc::string::String,
        #[doc = " API version of the container runtime. The string must be"]
        #[doc = " semver-compatible."]
        #[prost(string, tag = "4")] pub runtime_api_version: ::prost::alloc::string::String,
    }

    #[doc = " DNSConfig specifies the DNS servers and search domains of a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DnsConfig {
        #[doc = " List of DNS servers of the cluster."]
        #[prost(string, repeated, tag = "1")] pub servers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of DNS search domains of the cluster."]
        #[prost(string, repeated, tag = "2")] pub searches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of DNS options. See <https://linux.die.net/man/5/resolv.conf>"]
        #[doc = " for all available options."]
        #[prost(string, repeated, tag = "3")] pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }

    #[doc = " PortMapping specifies the port mapping configurations of a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortMapping {
        #[doc = " Protocol of the port mapping."]
        #[prost(enumeration = "Protocol", tag = "1")] pub protocol: i32,
        #[doc = " Port number within the container. Default: 0 (not specified)."]
        #[prost(int32, tag = "2")] pub container_port: i32,
        #[doc = " Port number on the host. Default: 0 (not specified)."]
        #[prost(int32, tag = "3")] pub host_port: i32,
        #[doc = " Host IP."]
        #[prost(string, tag = "4")] pub host_ip: ::prost::alloc::string::String,
    }

    #[doc = " Mount specifies a host volume to mount into a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Mount {
        #[doc = " Path of the mount within the container."]
        #[prost(string, tag = "1")] pub container_path: ::prost::alloc::string::String,
        #[doc = " Path of the mount on the host. If the hostPath doesn\'t exist, then runtimes"]
        #[doc = " should report error. If the hostpath is a symbolic link, runtimes should"]
        #[doc = " follow the symlink and mount the real destination to container."]
        #[prost(string, tag = "2")] pub host_path: ::prost::alloc::string::String,
        #[doc = " If set, the mount is read-only."]
        #[prost(bool, tag = "3")] pub readonly: bool,
        #[doc = " If set, the mount needs SELinux relabeling."]
        #[prost(bool, tag = "4")] pub selinux_relabel: bool,
        #[doc = " Requested propagation mode."]
        #[prost(enumeration = "MountPropagation", tag = "5")] pub propagation: i32,
    }

    #[doc = " IDMapping describes host to container ID mappings for a pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdMapping {
        #[doc = " HostId is the id on the host."]
        #[prost(uint32, tag = "1")] pub host_id: u32,
        #[doc = " ContainerId is the id in the container."]
        #[prost(uint32, tag = "2")] pub container_id: u32,
        #[doc = " Length is the size of the range to map."]
        #[prost(uint32, tag = "3")] pub length: u32,
    }

    #[doc = " UserNamespace describes the intended user namespace configuration for a pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserNamespace {
        #[doc = " Mode is the NamespaceMode for this UserNamespace."]
        #[doc = " Note: NamespaceMode for UserNamespace currently supports only POD and NODE, not CONTAINER OR TARGET."]
        #[prost(enumeration = "NamespaceMode", tag = "1")] pub mode: i32,
        #[doc = " Uids specifies the UID mappings for the user namespace."]
        #[prost(message, repeated, tag = "2")] pub uids: ::prost::alloc::vec::Vec<IdMapping>,
        #[doc = " Gids specifies the GID mappings for the user namespace."]
        #[prost(message, repeated, tag = "3")] pub gids: ::prost::alloc::vec::Vec<IdMapping>,
    }

    #[doc = " NamespaceOption provides options for Linux namespaces."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NamespaceOption {
        #[doc = " Network namespace for this container/sandbox."]
        #[doc = " Note: There is currently no way to set CONTAINER scoped network in the Kubernetes API."]
        #[doc = " Namespaces currently set by the kubelet: POD, NODE"]
        #[prost(enumeration = "NamespaceMode", tag = "1")] pub network: i32,
        #[doc = " PID namespace for this container/sandbox."]
        #[doc = " Note: The CRI default is POD, but the v1.PodSpec default is CONTAINER."]
        #[doc = " The kubelet\'s runtime manager will set this to CONTAINER explicitly for v1 pods."]
        #[doc = " Namespaces currently set by the kubelet: POD, CONTAINER, NODE, TARGET"]
        #[prost(enumeration = "NamespaceMode", tag = "2")] pub pid: i32,
        #[doc = " IPC namespace for this container/sandbox."]
        #[doc = " Note: There is currently no way to set CONTAINER scoped IPC in the Kubernetes API."]
        #[doc = " Namespaces currently set by the kubelet: POD, NODE"]
        #[prost(enumeration = "NamespaceMode", tag = "3")] pub ipc: i32,
        #[doc = " Target Container ID for NamespaceMode of TARGET. This container must have been"]
        #[doc = " previously created in the same pod. It is not possible to specify different targets"]
        #[doc = " for each namespace."]
        #[prost(string, tag = "4")] pub target_id: ::prost::alloc::string::String,
        #[doc = " UsernsOptions for this pod sandbox."]
        #[doc = " The Kubelet picks the user namespace configuration to use for the pod sandbox.  The mappings"]
        #[doc = " are specified as part of the UserNamespace struct.  If the struct is nil, then the POD mode"]
        #[doc = " must be assumed.  This is done for backward compatibility with older Kubelet versions that"]
        #[doc = " do not set a user namespace."]
        #[prost(message, optional, tag = "5")] pub userns_options: ::core::option::Option<UserNamespace>,
    }

    #[doc = " Int64Value is the wrapper of int64."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Int64Value {
        #[doc = " The value."]
        #[prost(int64, tag = "1")] pub value: i64,
    }

    #[doc = " LinuxSandboxSecurityContext holds linux security configuration that will be"]
    #[doc = " applied to a sandbox. Note that:"]
    #[doc = " 1) It does not apply to containers in the pods."]
    #[doc = " 2) It may not be applicable to a PodSandbox which does not contain any running"]
    #[doc = "     process."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxSandboxSecurityContext {
        #[doc = " Configurations for the sandbox\'s namespaces."]
        #[doc = " This will be used only if the PodSandbox uses namespace for isolation."]
        #[prost(message, optional, tag = "1")] pub namespace_options: ::core::option::Option<NamespaceOption>,
        #[doc = " Optional SELinux context to be applied."]
        #[prost(message, optional, tag = "2")] pub selinux_options: ::core::option::Option<SeLinuxOption>,
        #[doc = " UID to run sandbox processes as, when applicable."]
        #[prost(message, optional, tag = "3")] pub run_as_user: ::core::option::Option<Int64Value>,
        #[doc = " GID to run sandbox processes as, when applicable. run_as_group should only"]
        #[doc = " be specified when run_as_user is specified; otherwise, the runtime MUST error."]
        #[prost(message, optional, tag = "8")] pub run_as_group: ::core::option::Option<Int64Value>,
        #[doc = " If set, the root filesystem of the sandbox is read-only."]
        #[prost(bool, tag = "4")] pub readonly_rootfs: bool,
        #[doc = " List of groups applied to the first process run in the sandbox, in"]
        #[doc = " addition to the sandbox\'s primary GID."]
        #[prost(int64, repeated, tag = "5")] pub supplemental_groups: ::prost::alloc::vec::Vec<i64>,
        #[doc = " Indicates whether the sandbox will be asked to run a privileged"]
        #[doc = " container. If a privileged container is to be executed within it, this"]
        #[doc = " MUST be true."]
        #[doc = " This allows a sandbox to take additional security precautions if no"]
        #[doc = " privileged containers are expected to be run."]
        #[prost(bool, tag = "6")] pub privileged: bool,
        #[doc = " Seccomp profile for the sandbox."]
        #[prost(message, optional, tag = "9")] pub seccomp: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the sandbox."]
        #[prost(message, optional, tag = "10")] pub apparmor: ::core::option::Option<SecurityProfile>,
        #[doc = " Seccomp profile for the sandbox, candidate values are:"]
        #[doc = " * runtime/default: the default profile for the container runtime"]
        #[doc = " * unconfined: unconfined profile, ie, no seccomp sandboxing"]
        #[doc = " * localhost/<full-path-to-profile>: the profile installed on the node."]
        #[doc = "    <full-path-to-profile> is the full path of the profile."]
        #[doc = " Default: \"\", which is identical with unconfined."]
        #[deprecated]
        #[prost(string, tag = "7")] pub seccomp_profile_path: ::prost::alloc::string::String,
    }

    #[doc = " A security profile which can be used for sandboxes and containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityProfile {
        #[doc = " Indicator which `ProfileType` should be applied."]
        #[prost(enumeration = "security_profile::ProfileType", tag = "1")] pub profile_type: i32,
        #[doc = " Indicates that a pre-defined profile on the node should be used."]
        #[doc = " Must only be set if `ProfileType` is `Localhost`."]
        #[doc = " For seccomp, it must be an absolute path to the seccomp profile."]
        #[doc = " For AppArmor, this field is the AppArmor `<profile name>/`"]
        #[prost(string, tag = "2")] pub localhost_ref: ::prost::alloc::string::String,
    }

    #[doc = " Nested message and enum types in `SecurityProfile`."]
    pub mod security_profile {
        #[doc = " Available profile types."]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ProfileType { #[doc = " The container runtime default profile should be used."] RuntimeDefault = 0, #[doc = " Disable the feature for the sandbox or the container."] Unconfined = 1, #[doc = " A pre-defined profile on the node should be used."] Localhost = 2 }

        impl ProfileType {
            #[doc = " String value of the enum field names used in the ProtoBuf definition."]
            #[doc = ""]
            #[doc = " The values are not transformed in any way and thus are considered stable"]
            #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ProfileType::RuntimeDefault => "RuntimeDefault",
                    ProfileType::Unconfined => "Unconfined",
                    ProfileType::Localhost => "Localhost",
                }
            }
        }
    }

    #[doc = " LinuxPodSandboxConfig holds platform-specific configurations for Linux"]
    #[doc = " host platforms and Linux-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxConfig {
        #[doc = " Parent cgroup of the PodSandbox."]
        #[doc = " The cgroupfs style syntax will be used, but the container runtime can"]
        #[doc = " convert it to systemd semantics if needed."]
        #[prost(string, tag = "1")] pub cgroup_parent: ::prost::alloc::string::String,
        #[doc = " LinuxSandboxSecurityContext holds sandbox security attributes."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<LinuxSandboxSecurityContext>,
        #[doc = " Sysctls holds linux sysctls config for the sandbox."]
        #[prost(map = "string, string", tag = "3")] pub sysctls: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Optional overhead represents the overheads associated with this sandbox"]
        #[prost(message, optional, tag = "4")] pub overhead: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Optional resources represents the sum of container resources for this sandbox"]
        #[prost(message, optional, tag = "5")] pub resources: ::core::option::Option<LinuxContainerResources>,
    }

    #[doc = " PodSandboxMetadata holds all necessary information for building the sandbox name."]
    #[doc = " The container runtime is encouraged to expose the metadata associated with the"]
    #[doc = " PodSandbox in its user interface for better user experience. For example,"]
    #[doc = " the runtime can construct a unique PodSandboxName based on the metadata."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxMetadata {
        #[doc = " Pod name of the sandbox. Same as the pod name in the Pod ObjectMeta."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Pod UID of the sandbox. Same as the pod UID in the Pod ObjectMeta."]
        #[prost(string, tag = "2")] pub uid: ::prost::alloc::string::String,
        #[doc = " Pod namespace of the sandbox. Same as the pod namespace in the Pod ObjectMeta."]
        #[prost(string, tag = "3")] pub namespace: ::prost::alloc::string::String,
        #[doc = " Attempt number of creating the sandbox. Default: 0."]
        #[prost(uint32, tag = "4")] pub attempt: u32,
    }

    #[doc = " PodSandboxConfig holds all the required and optional fields for creating a"]
    #[doc = " sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxConfig {
        #[doc = " Metadata of the sandbox. This information will uniquely identify the"]
        #[doc = " sandbox, and the runtime should leverage this to ensure correct"]
        #[doc = " operation. The runtime may also use this information to improve UX, such"]
        #[doc = " as by constructing a readable name."]
        #[prost(message, optional, tag = "1")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " Hostname of the sandbox. Hostname could only be empty when the pod"]
        #[doc = " network namespace is NODE."]
        #[prost(string, tag = "2")] pub hostname: ::prost::alloc::string::String,
        #[doc = " Path to the directory on the host in which container log files are"]
        #[doc = " stored."]
        #[doc = " By default the log of a container going into the LogDirectory will be"]
        #[doc = " hooked up to STDOUT and STDERR. However, the LogDirectory may contain"]
        #[doc = " binary log files with structured logging data from the individual"]
        #[doc = " containers. For example, the files might be newline separated JSON"]
        #[doc = " structured logs, systemd-journald journal files, gRPC trace files, etc."]
        #[doc = " E.g.,"]
        #[doc = "      PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`"]
        #[doc = "      ContainerConfig.LogPath = `containerName/Instance#.log`"]
        #[prost(string, tag = "3")] pub log_directory: ::prost::alloc::string::String,
        #[doc = " DNS config for the sandbox."]
        #[prost(message, optional, tag = "4")] pub dns_config: ::core::option::Option<DnsConfig>,
        #[doc = " Port mappings for the sandbox."]
        #[prost(message, repeated, tag = "5")] pub port_mappings: ::prost::alloc::vec::Vec<PortMapping>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "6")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map that may be set by the kubelet to store and"]
        #[doc = " retrieve arbitrary metadata. This will include any annotations set on a"]
        #[doc = " pod through the Kubernetes API."]
        #[doc = ""]
        #[doc = " Annotations MUST NOT be altered by the runtime; the annotations stored"]
        #[doc = " here MUST be returned in the PodSandboxStatus associated with the pod"]
        #[doc = " this PodSandboxConfig creates."]
        #[doc = ""]
        #[doc = " In general, in order to preserve a well-defined interface between the"]
        #[doc = " kubelet and the container runtime, annotations SHOULD NOT influence"]
        #[doc = " runtime behaviour."]
        #[doc = ""]
        #[doc = " Annotations can also be useful for runtime authors to experiment with"]
        #[doc = " new features that are opaque to the Kubernetes APIs (both user-facing"]
        #[doc = " and the CRI). Whenever possible, however, runtime authors SHOULD"]
        #[doc = " consider proposing new typed fields for any new features instead."]
        #[prost(map = "string, string", tag = "7")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Optional configurations specific to Linux hosts."]
        #[prost(message, optional, tag = "8")] pub linux: ::core::option::Option<LinuxPodSandboxConfig>,
        #[doc = " Optional configurations specific to Windows hosts."]
        #[prost(message, optional, tag = "9")] pub windows: ::core::option::Option<WindowsPodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunPodSandboxRequest {
        #[doc = " Configuration for creating a PodSandbox."]
        #[prost(message, optional, tag = "1")] pub config: ::core::option::Option<PodSandboxConfig>,
        #[doc = " Named runtime configuration to use for this PodSandbox."]
        #[doc = " If the runtime handler is unknown, this request should be rejected.  An"]
        #[doc = " empty string should select the default handler, equivalent to the"]
        #[doc = " behavior before this feature was added."]
        #[doc = " See <https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class>"]
        #[prost(string, tag = "2")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunPodSandboxResponse {
        #[doc = " ID of the PodSandbox to run."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopPodSandboxRequest {
        #[doc = " ID of the PodSandbox to stop."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopPodSandboxResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemovePodSandboxRequest {
        #[doc = " ID of the PodSandbox to remove."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemovePodSandboxResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatusRequest {
        #[doc = " ID of the PodSandbox for which to retrieve status."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Verbose indicates whether to return extra information about the pod sandbox."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[doc = " PodIP represents an ip of a Pod"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodIp {
        #[doc = " an ip is a string representation of an IPv4 or an IPv6"]
        #[prost(string, tag = "1")] pub ip: ::prost::alloc::string::String,
    }

    #[doc = " PodSandboxNetworkStatus is the status of the network for a PodSandbox."]
    #[doc = " Currently ignored for pods sharing the host networking namespace."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxNetworkStatus {
        #[doc = " IP address of the PodSandbox."]
        #[prost(string, tag = "1")] pub ip: ::prost::alloc::string::String,
        #[doc = " list of additional ips (not inclusive of PodSandboxNetworkStatus.Ip) of the PodSandBoxNetworkStatus"]
        #[prost(message, repeated, tag = "2")] pub additional_ips: ::prost::alloc::vec::Vec<PodIp>,
    }

    #[doc = " Namespace contains paths to the namespaces."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Namespace {
        #[doc = " Namespace options for Linux namespaces."]
        #[prost(message, optional, tag = "2")] pub options: ::core::option::Option<NamespaceOption>,
    }

    #[doc = " LinuxSandboxStatus contains status specific to Linux sandboxes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxStatus {
        #[doc = " Paths to the sandbox\'s namespaces."]
        #[prost(message, optional, tag = "1")] pub namespaces: ::core::option::Option<Namespace>,
    }

    #[doc = " PodSandboxStatus contains the status of the PodSandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatus {
        #[doc = " ID of the sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the sandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " State of the sandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "3")] pub state: i32,
        #[doc = " Creation timestamp of the sandbox in nanoseconds. Must be > 0."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Network contains network status if network is handled by the runtime."]
        #[prost(message, optional, tag = "5")] pub network: ::core::option::Option<PodSandboxNetworkStatus>,
        #[doc = " Linux-specific status to a pod sandbox."]
        #[prost(message, optional, tag = "6")] pub linux: ::core::option::Option<LinuxPodSandboxStatus>,
        #[doc = " Labels are key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "7")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxConfig used to"]
        #[doc = " instantiate the pod sandbox this status represents."]
        #[prost(map = "string, string", tag = "8")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " runtime configuration used for this PodSandbox."]
        #[prost(string, tag = "9")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatusResponse {
        #[doc = " Status of the PodSandbox."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<PodSandboxStatus>,
        #[doc = " Info is extra information of the PodSandbox. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. network namespace for linux container based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " PodSandboxStateValue is the wrapper of PodSandboxState."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStateValue {
        #[doc = " State of the sandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "1")] pub state: i32,
    }

    #[doc = " PodSandboxFilter is used to filter a list of PodSandboxes."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxFilter {
        #[doc = " ID of the sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " State of the sandbox."]
        #[prost(message, optional, tag = "2")] pub state: ::core::option::Option<PodSandboxStateValue>,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "3")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxRequest {
        #[doc = " PodSandboxFilter to filter a list of PodSandboxes."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<PodSandboxFilter>,
    }

    #[doc = " PodSandbox contains minimal information about a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandbox {
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the PodSandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " State of the PodSandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "3")] pub state: i32,
        #[doc = " Creation timestamps of the PodSandbox in nanoseconds. Must be > 0."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Labels of the PodSandbox."]
        #[prost(map = "string, string", tag = "5")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxConfig used to"]
        #[doc = " instantiate this PodSandbox."]
        #[prost(map = "string, string", tag = "6")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " runtime configuration used for this PodSandbox."]
        #[prost(string, tag = "7")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxResponse {
        #[doc = " List of PodSandboxes."]
        #[prost(message, repeated, tag = "1")] pub items: ::prost::alloc::vec::Vec<PodSandbox>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsRequest {
        #[doc = " ID of the pod sandbox for which to retrieve stats."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsResponse {
        #[prost(message, optional, tag = "1")] pub stats: ::core::option::Option<PodSandboxStats>,
    }

    #[doc = " PodSandboxStatsFilter is used to filter the list of pod sandboxes to retrieve stats for."]
    #[doc = " All those fields are combined with \'AND\'."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsFilter {
        #[doc = " ID of the pod sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "2")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxStatsRequest {
        #[doc = " Filter for the list request."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<PodSandboxStatsFilter>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxStatsResponse {
        #[doc = " Stats of the pod sandbox."]
        #[prost(message, repeated, tag = "1")] pub stats: ::prost::alloc::vec::Vec<PodSandboxStats>,
    }

    #[doc = " PodSandboxAttributes provides basic information of the pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxAttributes {
        #[doc = " ID of the pod sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the pod sandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "3")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxStatus used to"]
        #[doc = " instantiate the PodSandbox this status represents."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " PodSandboxStats provides the resource usage statistics for a pod."]
    #[doc = " The linux or windows field will be populated depending on the platform."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStats {
        #[doc = " Information of the pod."]
        #[prost(message, optional, tag = "1")] pub attributes: ::core::option::Option<PodSandboxAttributes>,
        #[doc = " Stats from linux."]
        #[prost(message, optional, tag = "2")] pub linux: ::core::option::Option<LinuxPodSandboxStats>,
        #[doc = " Stats from windows."]
        #[prost(message, optional, tag = "3")] pub windows: ::core::option::Option<WindowsPodSandboxStats>,
    }

    #[doc = " LinuxPodSandboxStats provides the resource usage statistics for a pod sandbox on linux."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxStats {
        #[doc = " CPU usage gathered for the pod sandbox."]
        #[prost(message, optional, tag = "1")] pub cpu: ::core::option::Option<CpuUsage>,
        #[doc = " Memory usage gathered for the pod sandbox."]
        #[prost(message, optional, tag = "2")] pub memory: ::core::option::Option<MemoryUsage>,
        #[doc = " Network usage gathered for the pod sandbox"]
        #[prost(message, optional, tag = "3")] pub network: ::core::option::Option<NetworkUsage>,
        #[doc = " Stats pertaining to processes in the pod sandbox."]
        #[prost(message, optional, tag = "4")] pub process: ::core::option::Option<ProcessUsage>,
        #[doc = " Stats of containers in the measured pod sandbox."]
        #[prost(message, repeated, tag = "5")] pub containers: ::prost::alloc::vec::Vec<ContainerStats>,
    }

    #[doc = " WindowsPodSandboxStats provides the resource usage statistics for a pod sandbox on windows"]
    #[doc = ""]
    #[doc = " TODO: Add stats relevant to windows."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsPodSandboxStats {}

    #[doc = " NetworkUsage contains data about network resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkUsage {
        #[doc = " The time at which these stats were updated."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Stats for the default network interface."]
        #[prost(message, optional, tag = "2")] pub default_interface: ::core::option::Option<NetworkInterfaceUsage>,
        #[doc = " Stats for all found network interfaces, excluding the default."]
        #[prost(message, repeated, tag = "3")] pub interfaces: ::prost::alloc::vec::Vec<NetworkInterfaceUsage>,
    }

    #[doc = " NetworkInterfaceUsage contains resource value data about a network interface."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkInterfaceUsage {
        #[doc = " The name of the network interface."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Cumulative count of bytes received."]
        #[prost(message, optional, tag = "2")] pub rx_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of receive errors encountered."]
        #[prost(message, optional, tag = "3")] pub rx_errors: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of bytes transmitted."]
        #[prost(message, optional, tag = "4")] pub tx_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of transmit errors encountered."]
        #[prost(message, optional, tag = "5")] pub tx_errors: ::core::option::Option<UInt64Value>,
    }

    #[doc = " ProcessUsage are stats pertaining to processes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessUsage {
        #[doc = " The time at which these stats were updated."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Number of processes."]
        #[prost(message, optional, tag = "2")] pub process_count: ::core::option::Option<UInt64Value>,
    }

    #[doc = " ImageSpec is an internal representation of an image."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageSpec {
        #[doc = " Container\'s Image field (e.g. imageID or imageDigest)."]
        #[prost(string, tag = "1")] pub image: ::prost::alloc::string::String,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " ImageSpec Annotations can be used to help the runtime target specific"]
        #[doc = " images in multi-arch images."]
        #[prost(map = "string, string", tag = "2")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyValue {
        #[prost(string, tag = "1")] pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub value: ::prost::alloc::string::String,
    }

    #[doc = " LinuxContainerResources specifies Linux specific configuration for"]
    #[doc = " resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerResources {
        #[doc = " CPU CFS (Completely Fair Scheduler) period. Default: 0 (not specified)."]
        #[prost(int64, tag = "1")] pub cpu_period: i64,
        #[doc = " CPU CFS (Completely Fair Scheduler) quota. Default: 0 (not specified)."]
        #[prost(int64, tag = "2")] pub cpu_quota: i64,
        #[doc = " CPU shares (relative weight vs. other containers). Default: 0 (not specified)."]
        #[prost(int64, tag = "3")] pub cpu_shares: i64,
        #[doc = " Memory limit in bytes. Default: 0 (not specified)."]
        #[prost(int64, tag = "4")] pub memory_limit_in_bytes: i64,
        #[doc = " OOMScoreAdj adjusts the oom-killer score. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub oom_score_adj: i64,
        #[doc = " CpusetCpus constrains the allowed set of logical CPUs. Default: \"\" (not specified)."]
        #[prost(string, tag = "6")] pub cpuset_cpus: ::prost::alloc::string::String,
        #[doc = " CpusetMems constrains the allowed set of memory nodes. Default: \"\" (not specified)."]
        #[prost(string, tag = "7")] pub cpuset_mems: ::prost::alloc::string::String,
        #[doc = " List of HugepageLimits to limit the HugeTLB usage of container per page size. Default: nil (not specified)."]
        #[prost(message, repeated, tag = "8")] pub hugepage_limits: ::prost::alloc::vec::Vec<HugepageLimit>,
        #[doc = " Unified resources for cgroup v2. Default: nil (not specified)."]
        #[doc = " Each key/value in the map refers to the cgroup v2."]
        #[doc = " e.g. \"memory.max\": \"6937202688\" or \"io.weight\": \"default 100\"."]
        #[prost(map = "string, string", tag = "9")] pub unified: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Memory swap limit in bytes. Default 0 (not specified)."]
        #[prost(int64, tag = "10")] pub memory_swap_limit_in_bytes: i64,
    }

    #[doc = " HugepageLimit corresponds to the file`hugetlb.<hugepagesize>.limit_in_byte` in container level cgroup."]
    #[doc = " For example, `PageSize=1GB`, `Limit=1073741824` means setting `1073741824` bytes to hugetlb.1GB.limit_in_bytes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HugepageLimit {
        #[doc = " The value of PageSize has the format <size><unit-prefix>B (2MB, 1GB),"]
        #[doc = " and must match the <hugepagesize> of the corresponding control file found in `hugetlb.<hugepagesize>.limit_in_bytes`."]
        #[doc = " The values of <unit-prefix> are intended to be parsed using base 1024(\"1KB\" = 1024, \"1MB\" = 1048576, etc)."]
        #[prost(string, tag = "1")] pub page_size: ::prost::alloc::string::String,
        #[doc = " limit in bytes of hugepagesize HugeTLB usage."]
        #[prost(uint64, tag = "2")] pub limit: u64,
    }

    #[doc = " SELinuxOption are the labels to be applied to the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SeLinuxOption {
        #[prost(string, tag = "1")] pub user: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub role: ::prost::alloc::string::String,
        #[prost(string, tag = "3")] pub r#type: ::prost::alloc::string::String,
        #[prost(string, tag = "4")] pub level: ::prost::alloc::string::String,
    }

    #[doc = " Capability contains the container capabilities to add or drop"]
    #[doc = " Dropping a capability will drop it from all sets."]
    #[doc = " If a capability is added to only the add_capabilities list then it gets added to permitted,"]
    #[doc = " inheritable, effective and bounding sets, i.e. all sets except the ambient set."]
    #[doc = " If a capability is added to only the add_ambient_capabilities list then it gets added to all sets, i.e permitted"]
    #[doc = " inheritable, effective, bounding and ambient sets."]
    #[doc = " If a capability is added to add_capabilities and add_ambient_capabilities lists then it gets added to all sets, i.e."]
    #[doc = " permitted, inheritable, effective, bounding and ambient sets."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Capability {
        #[doc = " List of capabilities to add."]
        #[prost(string, repeated, tag = "1")] pub add_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of capabilities to drop."]
        #[prost(string, repeated, tag = "2")] pub drop_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of ambient capabilities to add."]
        #[prost(string, repeated, tag = "3")] pub add_ambient_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }

    #[doc = " LinuxContainerSecurityContext holds linux security configuration that will be applied to a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerSecurityContext {
        #[doc = " Capabilities to add or drop."]
        #[prost(message, optional, tag = "1")] pub capabilities: ::core::option::Option<Capability>,
        #[doc = " If set, run container in privileged mode."]
        #[doc = " Privileged mode is incompatible with the following options. If"]
        #[doc = " privileged is set, the following features MAY have no effect:"]
        #[doc = " 1. capabilities"]
        #[doc = " 2. selinux_options"]
        #[doc = " 4. seccomp"]
        #[doc = " 5. apparmor"]
        #[doc = ""]
        #[doc = " Privileged mode implies the following specific options are applied:"]
        #[doc = " 1. All capabilities are added."]
        #[doc = " 2. Sensitive paths, such as kernel module paths within sysfs, are not masked."]
        #[doc = " 3. Any sysfs and procfs mounts are mounted RW."]
        #[doc = " 4. AppArmor confinement is not applied."]
        #[doc = " 5. Seccomp restrictions are not applied."]
        #[doc = " 6. The device cgroup does not restrict access to any devices."]
        #[doc = " 7. All devices from the host\'s /dev are available within the container."]
        #[doc = " 8. SELinux restrictions are not applied (e.g. label=disabled)."]
        #[prost(bool, tag = "2")] pub privileged: bool,
        #[doc = " Configurations for the container\'s namespaces."]
        #[doc = " Only used if the container uses namespace for isolation."]
        #[prost(message, optional, tag = "3")] pub namespace_options: ::core::option::Option<NamespaceOption>,
        #[doc = " SELinux context to be optionally applied."]
        #[prost(message, optional, tag = "4")] pub selinux_options: ::core::option::Option<SeLinuxOption>,
        #[doc = " UID to run the container process as. Only one of run_as_user and"]
        #[doc = " run_as_username can be specified at a time."]
        #[prost(message, optional, tag = "5")] pub run_as_user: ::core::option::Option<Int64Value>,
        #[doc = " GID to run the container process as. run_as_group should only be specified"]
        #[doc = " when run_as_user or run_as_username is specified; otherwise, the runtime"]
        #[doc = " MUST error."]
        #[prost(message, optional, tag = "12")] pub run_as_group: ::core::option::Option<Int64Value>,
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image (i.e. in the /etc/passwd inside the image),"]
        #[doc = " and be resolved there by the runtime; otherwise, the runtime MUST error."]
        #[prost(string, tag = "6")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " If set, the root filesystem of the container is read-only."]
        #[prost(bool, tag = "7")] pub readonly_rootfs: bool,
        #[doc = " List of groups applied to the first process run in the container, in"]
        #[doc = " addition to the container\'s primary GID."]
        #[prost(int64, repeated, tag = "8")] pub supplemental_groups: ::prost::alloc::vec::Vec<i64>,
        #[doc = " no_new_privs defines if the flag for no_new_privs should be set on the"]
        #[doc = " container."]
        #[prost(bool, tag = "11")] pub no_new_privs: bool,
        #[doc = " masked_paths is a slice of paths that should be masked by the container"]
        #[doc = " runtime, this can be passed directly to the OCI spec."]
        #[prost(string, repeated, tag = "13")] pub masked_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " readonly_paths is a slice of paths that should be set as readonly by the"]
        #[doc = " container runtime, this can be passed directly to the OCI spec."]
        #[prost(string, repeated, tag = "14")] pub readonly_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Seccomp profile for the container."]
        #[prost(message, optional, tag = "15")] pub seccomp: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the container."]
        #[prost(message, optional, tag = "16")] pub apparmor: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the container, candidate values are:"]
        #[doc = " * runtime/default: equivalent to not specifying a profile."]
        #[doc = " * unconfined: no profiles are loaded"]
        #[doc = " * localhost/<profile_name>: profile loaded on the node"]
        #[doc = "     (localhost) by name. The possible profile names are detailed at"]
        #[doc = "     <https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference>"]
        #[deprecated]
        #[prost(string, tag = "9")] pub apparmor_profile: ::prost::alloc::string::String,
        #[doc = " Seccomp profile for the container, candidate values are:"]
        #[doc = " * runtime/default: the default profile for the container runtime"]
        #[doc = " * unconfined: unconfined profile, ie, no seccomp sandboxing"]
        #[doc = " * localhost/<full-path-to-profile>: the profile installed on the node."]
        #[doc = "    <full-path-to-profile> is the full path of the profile."]
        #[doc = " Default: \"\", which is identical with unconfined."]
        #[deprecated]
        #[prost(string, tag = "10")] pub seccomp_profile_path: ::prost::alloc::string::String,
    }

    #[doc = " LinuxContainerConfig contains platform-specific configuration for"]
    #[doc = " Linux-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerConfig {
        #[doc = " Resources specification for the container."]
        #[prost(message, optional, tag = "1")] pub resources: ::core::option::Option<LinuxContainerResources>,
        #[doc = " LinuxContainerSecurityContext configuration for the container."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<LinuxContainerSecurityContext>,
    }

    #[doc = " WindowsSandboxSecurityContext holds platform-specific configurations that will be"]
    #[doc = " applied to a sandbox."]
    #[doc = " These settings will only apply to the sandbox container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsSandboxSecurityContext {
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image and be resolved there by the runtime;"]
        #[doc = " otherwise, the runtime MUST return error."]
        #[prost(string, tag = "1")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " The contents of the GMSA credential spec to use to run this container."]
        #[prost(string, tag = "2")] pub credential_spec: ::prost::alloc::string::String,
        #[doc = " Indicates whether the container requested to run as a HostProcess container."]
        #[prost(bool, tag = "3")] pub host_process: bool,
    }

    #[doc = " WindowsPodSandboxConfig holds platform-specific configurations for Windows"]
    #[doc = " host platforms and Windows-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsPodSandboxConfig {
        #[doc = " WindowsSandboxSecurityContext holds sandbox security attributes."]
        #[prost(message, optional, tag = "1")] pub security_context: ::core::option::Option<WindowsSandboxSecurityContext>,
    }

    #[doc = " WindowsContainerSecurityContext holds windows security configuration that will be applied to a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerSecurityContext {
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image and be resolved there by the runtime;"]
        #[doc = " otherwise, the runtime MUST return error."]
        #[prost(string, tag = "1")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " The contents of the GMSA credential spec to use to run this container."]
        #[prost(string, tag = "2")] pub credential_spec: ::prost::alloc::string::String,
        #[doc = " Indicates whether a container is to be run as a HostProcess container."]
        #[prost(bool, tag = "3")] pub host_process: bool,
    }

    #[doc = " WindowsContainerConfig contains platform-specific configuration for"]
    #[doc = " Windows-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerConfig {
        #[doc = " Resources specification for the container."]
        #[prost(message, optional, tag = "1")] pub resources: ::core::option::Option<WindowsContainerResources>,
        #[doc = " WindowsContainerSecurityContext configuration for the container."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<WindowsContainerSecurityContext>,
    }

    #[doc = " WindowsContainerResources specifies Windows specific configuration for"]
    #[doc = " resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerResources {
        #[doc = " CPU shares (relative weight vs. other containers). Default: 0 (not specified)."]
        #[prost(int64, tag = "1")] pub cpu_shares: i64,
        #[doc = " Number of CPUs available to the container. Default: 0 (not specified)."]
        #[prost(int64, tag = "2")] pub cpu_count: i64,
        #[doc = " Specifies the portion of processor cycles that this container can use as a percentage times 100."]
        #[prost(int64, tag = "3")] pub cpu_maximum: i64,
        #[doc = " Memory limit in bytes. Default: 0 (not specified)."]
        #[prost(int64, tag = "4")] pub memory_limit_in_bytes: i64,
        #[doc = " Specifies the size of the rootfs / scratch space in bytes to be configured for this container. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub rootfs_size_in_bytes: i64,
    }

    #[doc = " ContainerMetadata holds all necessary information for building the container"]
    #[doc = " name. The container runtime is encouraged to expose the metadata in its user"]
    #[doc = " interface for better user experience. E.g., runtime can construct a unique"]
    #[doc = " container name based on the metadata. Note that (name, attempt) is unique"]
    #[doc = " within a sandbox for the entire lifetime of the sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerMetadata {
        #[doc = " Name of the container. Same as the container name in the PodSpec."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Attempt number of creating the container. Default: 0."]
        #[prost(uint32, tag = "2")] pub attempt: u32,
    }

    #[doc = " Device specifies a host device to mount into a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        #[doc = " Path of the device within the container."]
        #[prost(string, tag = "1")] pub container_path: ::prost::alloc::string::String,
        #[doc = " Path of the device on the host."]
        #[prost(string, tag = "2")] pub host_path: ::prost::alloc::string::String,
        #[doc = " Cgroups permissions of the device, candidates are one or more of"]
        #[doc = " * r - allows container to read from the specified device."]
        #[doc = " * w - allows container to write to the specified device."]
        #[doc = " * m - allows container to create device files that do not yet exist."]
        #[prost(string, tag = "3")] pub permissions: ::prost::alloc::string::String,
    }

    #[doc = " ContainerConfig holds all the required and optional fields for creating a"]
    #[doc = " container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerConfig {
        #[doc = " Metadata of the container. This information will uniquely identify the"]
        #[doc = " container, and the runtime should leverage this to ensure correct"]
        #[doc = " operation. The runtime may also use this information to improve UX, such"]
        #[doc = " as by constructing a readable name."]
        #[prost(message, optional, tag = "1")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Image to use."]
        #[prost(message, optional, tag = "2")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Command to execute (i.e., entrypoint for docker)"]
        #[prost(string, repeated, tag = "3")] pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Args for the Command (i.e., command for docker)"]
        #[prost(string, repeated, tag = "4")] pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Current working directory of the command."]
        #[prost(string, tag = "5")] pub working_dir: ::prost::alloc::string::String,
        #[doc = " List of environment variable to set in the container."]
        #[prost(message, repeated, tag = "6")] pub envs: ::prost::alloc::vec::Vec<KeyValue>,
        #[doc = " Mounts for the container."]
        #[prost(message, repeated, tag = "7")] pub mounts: ::prost::alloc::vec::Vec<Mount>,
        #[doc = " Devices for the container."]
        #[prost(message, repeated, tag = "8")] pub devices: ::prost::alloc::vec::Vec<Device>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[doc = " Label keys are of the form:"]
        #[doc = "      label-key ::= prefixed-name | name"]
        #[doc = "      prefixed-name ::= prefix \'/\' name"]
        #[doc = "      prefix ::= DNS_SUBDOMAIN"]
        #[doc = "      name ::= DNS_LABEL"]
        #[prost(map = "string, string", tag = "9")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map that may be used by the kubelet to store and"]
        #[doc = " retrieve arbitrary metadata."]
        #[doc = ""]
        #[doc = " Annotations MUST NOT be altered by the runtime; the annotations stored"]
        #[doc = " here MUST be returned in the ContainerStatus associated with the container"]
        #[doc = " this ContainerConfig creates."]
        #[doc = ""]
        #[doc = " In general, in order to preserve a well-defined interface between the"]
        #[doc = " kubelet and the container runtime, annotations SHOULD NOT influence"]
        #[doc = " runtime behaviour."]
        #[prost(map = "string, string", tag = "10")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Path relative to PodSandboxConfig.LogDirectory for container to store"]
        #[doc = " the log (STDOUT and STDERR) on the host."]
        #[doc = " E.g.,"]
        #[doc = "      PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`"]
        #[doc = "      ContainerConfig.LogPath = `containerName/Instance#.log`"]
        #[doc = ""]
        #[doc = " WARNING: Log management and how kubelet should interface with the"]
        #[doc = " container logs are under active discussion in"]
        #[doc = " <https://issues.k8s.io/24677.> There *may* be future change of direction"]
        #[doc = " for logging as the discussion carries on."]
        #[prost(string, tag = "11")] pub log_path: ::prost::alloc::string::String,
        #[doc = " Variables for interactive containers, these have very specialized"]
        #[doc = " use-cases (e.g. debugging)."]
        #[prost(bool, tag = "12")] pub stdin: bool,
        #[prost(bool, tag = "13")] pub stdin_once: bool,
        #[prost(bool, tag = "14")] pub tty: bool,
        #[doc = " Configuration specific to Linux containers."]
        #[prost(message, optional, tag = "15")] pub linux: ::core::option::Option<LinuxContainerConfig>,
        #[doc = " Configuration specific to Windows containers."]
        #[prost(message, optional, tag = "16")] pub windows: ::core::option::Option<WindowsContainerConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateContainerRequest {
        #[doc = " ID of the PodSandbox in which the container should be created."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Config of the container."]
        #[prost(message, optional, tag = "2")] pub config: ::core::option::Option<ContainerConfig>,
        #[doc = " Config of the PodSandbox. This is the same config that was passed"]
        #[doc = " to RunPodSandboxRequest to create the PodSandbox. It is passed again"]
        #[doc = " here just for easy reference. The PodSandboxConfig is immutable and"]
        #[doc = " remains the same throughout the lifetime of the pod."]
        #[prost(message, optional, tag = "3")] pub sandbox_config: ::core::option::Option<PodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateContainerResponse {
        #[doc = " ID of the created container."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartContainerRequest {
        #[doc = " ID of the container to start."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartContainerResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopContainerRequest {
        #[doc = " ID of the container to stop."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Timeout in seconds to wait for the container to stop before forcibly"]
        #[doc = " terminating it. Default: 0 (forcibly terminate the container immediately)"]
        #[prost(int64, tag = "2")] pub timeout: i64,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopContainerResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveContainerRequest {
        #[doc = " ID of the container to remove."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveContainerResponse {}

    #[doc = " ContainerStateValue is the wrapper of ContainerState."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStateValue {
        #[doc = " State of the container."]
        #[prost(enumeration = "ContainerState", tag = "1")] pub state: i32,
    }

    #[doc = " ContainerFilter is used to filter containers."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerFilter {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " State of the container."]
        #[prost(message, optional, tag = "2")] pub state: ::core::option::Option<ContainerStateValue>,
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "3")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "4")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainersRequest {
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ContainerFilter>,
    }

    #[doc = " Container provides the runtime information for a container, such as ID, hash,"]
    #[doc = " state of the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Container {
        #[doc = " ID of the container, used by the container runtime to identify"]
        #[doc = " a container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " ID of the sandbox to which this container belongs."]
        #[prost(string, tag = "2")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "3")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "4")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID."]
        #[prost(string, tag = "5")] pub image_ref: ::prost::alloc::string::String,
        #[doc = " State of the container."]
        #[prost(enumeration = "ContainerState", tag = "6")] pub state: i32,
        #[doc = " Creation time of the container in nanoseconds."]
        #[prost(int64, tag = "7")] pub created_at: i64,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "8")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate this Container."]
        #[prost(map = "string, string", tag = "9")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainersResponse {
        #[doc = " List of containers."]
        #[prost(message, repeated, tag = "1")] pub containers: ::prost::alloc::vec::Vec<Container>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatusRequest {
        #[doc = " ID of the container for which to retrieve status."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Verbose indicates whether to return extra information about the container."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[doc = " ContainerStatus represents the status of a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatus {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Status of the container."]
        #[prost(enumeration = "ContainerState", tag = "3")] pub state: i32,
        #[doc = " Creation time of the container in nanoseconds."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Start time of the container in nanoseconds. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub started_at: i64,
        #[doc = " Finish time of the container in nanoseconds. Default: 0 (not specified)."]
        #[prost(int64, tag = "6")] pub finished_at: i64,
        #[doc = " Exit code of the container. Only required when finished_at != 0. Default: 0."]
        #[prost(int32, tag = "7")] pub exit_code: i32,
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "8")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID"]
        #[prost(string, tag = "9")] pub image_ref: ::prost::alloc::string::String,
        #[doc = " Brief CamelCase string explaining why container is in its current state."]
        #[prost(string, tag = "10")] pub reason: ::prost::alloc::string::String,
        #[doc = " Human-readable message indicating details about why container is in its"]
        #[doc = " current state."]
        #[prost(string, tag = "11")] pub message: ::prost::alloc::string::String,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "12")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate the Container this status represents."]
        #[prost(map = "string, string", tag = "13")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Mounts for the container."]
        #[prost(message, repeated, tag = "14")] pub mounts: ::prost::alloc::vec::Vec<Mount>,
        #[doc = " Log path of container."]
        #[prost(string, tag = "15")] pub log_path: ::prost::alloc::string::String,
        #[doc = " Resource limits configuration of the container."]
        #[prost(message, optional, tag = "16")] pub resources: ::core::option::Option<ContainerResources>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatusResponse {
        #[doc = " Status of the container."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<ContainerStatus>,
        #[doc = " Info is extra information of the Container. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. pid for linux container based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " ContainerResources holds resource limits configuration for a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerResources {
        #[doc = " Resource limits configuration specific to Linux container."]
        #[prost(message, optional, tag = "1")] pub linux: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Resource limits configuration specific to Windows container."]
        #[prost(message, optional, tag = "2")] pub windows: ::core::option::Option<WindowsContainerResources>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateContainerResourcesRequest {
        #[doc = " ID of the container to update."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Resource configuration specific to Linux containers."]
        #[prost(message, optional, tag = "2")] pub linux: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Resource configuration specific to Windows containers."]
        #[prost(message, optional, tag = "3")] pub windows: ::core::option::Option<WindowsContainerResources>,
        #[doc = " Unstructured key-value map holding arbitrary additional information for"]
        #[doc = " container resources updating. This can be used for specifying experimental"]
        #[doc = " resources to update or other options to use when updating the container."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateContainerResourcesResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecSyncRequest {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Command to execute."]
        #[prost(string, repeated, tag = "2")] pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Timeout in seconds to stop the command. Default: 0 (run forever)."]
        #[prost(int64, tag = "3")] pub timeout: i64,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecSyncResponse {
        #[doc = " Captured command stdout output."]
        #[prost(bytes = "vec", tag = "1")] pub stdout: ::prost::alloc::vec::Vec<u8>,
        #[doc = " Captured command stderr output."]
        #[prost(bytes = "vec", tag = "2")] pub stderr: ::prost::alloc::vec::Vec<u8>,
        #[doc = " Exit code the command finished with. Default: 0 (success)."]
        #[prost(int32, tag = "3")] pub exit_code: i32,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecRequest {
        #[doc = " ID of the container in which to execute the command."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Command to execute."]
        #[prost(string, repeated, tag = "2")] pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Whether to exec the command in a TTY."]
        #[prost(bool, tag = "3")] pub tty: bool,
        #[doc = " Whether to stream stdin."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "4")] pub stdin: bool,
        #[doc = " Whether to stream stdout."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "5")] pub stdout: bool,
        #[doc = " Whether to stream stderr."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[doc = " If `tty` is true, `stderr` MUST be false. Multiplexing is not supported"]
        #[doc = " in this case. The output of stdout and stderr will be combined to a"]
        #[doc = " single stream."]
        #[prost(bool, tag = "6")] pub stderr: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecResponse {
        #[doc = " Fully qualified URL of the exec streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachRequest {
        #[doc = " ID of the container to which to attach."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Whether to stream stdin."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "2")] pub stdin: bool,
        #[doc = " Whether the process being attached is running in a TTY."]
        #[doc = " This must match the TTY setting in the ContainerConfig."]
        #[prost(bool, tag = "3")] pub tty: bool,
        #[doc = " Whether to stream stdout."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "4")] pub stdout: bool,
        #[doc = " Whether to stream stderr."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[doc = " If `tty` is true, `stderr` MUST be false. Multiplexing is not supported"]
        #[doc = " in this case. The output of stdout and stderr will be combined to a"]
        #[doc = " single stream."]
        #[prost(bool, tag = "5")] pub stderr: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachResponse {
        #[doc = " Fully qualified URL of the attach streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortForwardRequest {
        #[doc = " ID of the container to which to forward the port."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Port to forward."]
        #[prost(int32, repeated, tag = "2")] pub port: ::prost::alloc::vec::Vec<i32>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortForwardResponse {
        #[doc = " Fully qualified URL of the port-forward streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFilter {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListImagesRequest {
        #[doc = " Filter to list images."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ImageFilter>,
    }

    #[doc = " Basic information about a container image."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Image {
        #[doc = " ID of the image."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Other names by which this image is known."]
        #[prost(string, repeated, tag = "2")] pub repo_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Digests by which this image is known."]
        #[prost(string, repeated, tag = "3")] pub repo_digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Size of the image in bytes. Must be > 0."]
        #[prost(uint64, tag = "4")] pub size: u64,
        #[doc = " UID that will run the command(s). This is used as a default if no user is"]
        #[doc = " specified when creating the container. UID and the following user name"]
        #[doc = " are mutually exclusive."]
        #[prost(message, optional, tag = "5")] pub uid: ::core::option::Option<Int64Value>,
        #[doc = " User name that will run the command(s). This is used if UID is not set"]
        #[doc = " and no user is specified when creating container."]
        #[prost(string, tag = "6")] pub username: ::prost::alloc::string::String,
        #[doc = " ImageSpec for image which includes annotations"]
        #[prost(message, optional, tag = "7")] pub spec: ::core::option::Option<ImageSpec>,
        #[doc = " Recommendation on whether this image should be exempt from garbage collection."]
        #[doc = " It must only be treated as a recommendation -- the client can still request that the image be deleted,"]
        #[doc = " and the runtime must oblige."]
        #[prost(bool, tag = "8")] pub pinned: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListImagesResponse {
        #[doc = " List of images."]
        #[prost(message, repeated, tag = "1")] pub images: ::prost::alloc::vec::Vec<Image>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageStatusRequest {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Verbose indicates whether to return extra information about the image."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageStatusResponse {
        #[doc = " Status of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<Image>,
        #[doc = " Info is extra information of the Image. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful"]
        #[doc = " for debug, e.g. image config for oci image based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " AuthConfig contains authorization information for connecting to a registry."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthConfig {
        #[prost(string, tag = "1")] pub username: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub password: ::prost::alloc::string::String,
        #[prost(string, tag = "3")] pub auth: ::prost::alloc::string::String,
        #[prost(string, tag = "4")] pub server_address: ::prost::alloc::string::String,
        #[doc = " IdentityToken is used to authenticate the user and get"]
        #[doc = " an access token for the registry."]
        #[prost(string, tag = "5")] pub identity_token: ::prost::alloc::string::String,
        #[doc = " RegistryToken is a bearer token to be sent to a registry"]
        #[prost(string, tag = "6")] pub registry_token: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PullImageRequest {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Authentication configuration for pulling the image."]
        #[prost(message, optional, tag = "2")] pub auth: ::core::option::Option<AuthConfig>,
        #[doc = " Config of the PodSandbox, which is used to pull image in PodSandbox context."]
        #[prost(message, optional, tag = "3")] pub sandbox_config: ::core::option::Option<PodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PullImageResponse {
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID or digest."]
        #[prost(string, tag = "1")] pub image_ref: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveImageRequest {
        #[doc = " Spec of the image to remove."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveImageResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkConfig {
        #[doc = " CIDR to use for pod IP addresses. If the CIDR is empty, runtimes"]
        #[doc = " should omit it."]
        #[prost(string, tag = "1")] pub pod_cidr: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeConfig {
        #[prost(message, optional, tag = "1")] pub network_config: ::core::option::Option<NetworkConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateRuntimeConfigRequest {
        #[prost(message, optional, tag = "1")] pub runtime_config: ::core::option::Option<RuntimeConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateRuntimeConfigResponse {}

    #[doc = " RuntimeCondition contains condition information for the runtime."]
    #[doc = " There are 2 kinds of runtime conditions:"]
    #[doc = " 1. Required conditions: Conditions are required for kubelet to work"]
    #[doc = " properly. If any required condition is unmet, the node will be not ready."]
    #[doc = " The required conditions include:"]
    #[doc = "    * RuntimeReady: RuntimeReady means the runtime is up and ready to accept"]
    #[doc = "    basic containers e.g. container only needs host network."]
    #[doc = "    * NetworkReady: NetworkReady means the runtime network is up and ready to"]
    #[doc = "    accept containers which require container network."]
    #[doc = " 2. Optional conditions: Conditions are informative to the user, but kubelet"]
    #[doc = " will not rely on. Since condition type is an arbitrary string, all conditions"]
    #[doc = " not required are optional. These conditions will be exposed to users to help"]
    #[doc = " them understand the status of the system."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeCondition {
        #[doc = " Type of runtime condition."]
        #[prost(string, tag = "1")] pub r#type: ::prost::alloc::string::String,
        #[doc = " Status of the condition, one of true/false. Default: false."]
        #[prost(bool, tag = "2")] pub status: bool,
        #[doc = " Brief CamelCase string containing reason for the condition\'s last transition."]
        #[prost(string, tag = "3")] pub reason: ::prost::alloc::string::String,
        #[doc = " Human-readable message indicating details about last transition."]
        #[prost(string, tag = "4")] pub message: ::prost::alloc::string::String,
    }

    #[doc = " RuntimeStatus is information about the current status of the runtime."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeStatus {
        #[doc = " List of current observed runtime conditions."]
        #[prost(message, repeated, tag = "1")] pub conditions: ::prost::alloc::vec::Vec<RuntimeCondition>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatusRequest {
        #[doc = " Verbose indicates whether to return extra information about the runtime."]
        #[prost(bool, tag = "1")] pub verbose: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatusResponse {
        #[doc = " Status of the Runtime."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<RuntimeStatus>,
        #[doc = " Info is extra information of the Runtime. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. plugins used by the container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFsInfoRequest {}

    #[doc = " UInt64Value is the wrapper of uint64."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UInt64Value {
        #[doc = " The value."]
        #[prost(uint64, tag = "1")] pub value: u64,
    }

    #[doc = " FilesystemIdentifier uniquely identify the filesystem."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilesystemIdentifier {
        #[doc = " Mountpoint of a filesystem."]
        #[prost(string, tag = "1")] pub mountpoint: ::prost::alloc::string::String,
    }

    #[doc = " FilesystemUsage provides the filesystem usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilesystemUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " The unique identifier of the filesystem."]
        #[prost(message, optional, tag = "2")] pub fs_id: ::core::option::Option<FilesystemIdentifier>,
        #[doc = " UsedBytes represents the bytes used for images on the filesystem."]
        #[doc = " This may differ from the total bytes used on the filesystem and may not"]
        #[doc = " equal CapacityBytes - AvailableBytes."]
        #[prost(message, optional, tag = "3")] pub used_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " InodesUsed represents the inodes used by the images."]
        #[doc = " This may not equal InodesCapacity - InodesAvailable because the underlying"]
        #[doc = " filesystem may also be used for purposes other than storing images."]
        #[prost(message, optional, tag = "4")] pub inodes_used: ::core::option::Option<UInt64Value>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFsInfoResponse {
        #[doc = " Information of image filesystem(s)."]
        #[prost(message, repeated, tag = "1")] pub image_filesystems: ::prost::alloc::vec::Vec<FilesystemUsage>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsRequest {
        #[doc = " ID of the container for which to retrieve stats."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsResponse {
        #[doc = " Stats of the container."]
        #[prost(message, optional, tag = "1")] pub stats: ::core::option::Option<ContainerStats>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainerStatsRequest {
        #[doc = " Filter for the list request."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ContainerStatsFilter>,
    }

    #[doc = " ContainerStatsFilter is used to filter containers."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsFilter {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "2")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "3")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainerStatsResponse {
        #[doc = " Stats of the container."]
        #[prost(message, repeated, tag = "1")] pub stats: ::prost::alloc::vec::Vec<ContainerStats>,
    }

    #[doc = " ContainerAttributes provides basic information of the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerAttributes {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "3")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate the Container this status represents."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " ContainerStats provides the resource usage statistics for a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStats {
        #[doc = " Information of the container."]
        #[prost(message, optional, tag = "1")] pub attributes: ::core::option::Option<ContainerAttributes>,
        #[doc = " CPU usage gathered from the container."]
        #[prost(message, optional, tag = "2")] pub cpu: ::core::option::Option<CpuUsage>,
        #[doc = " Memory usage gathered from the container."]
        #[prost(message, optional, tag = "3")] pub memory: ::core::option::Option<MemoryUsage>,
        #[doc = " Usage of the writable layer."]
        #[prost(message, optional, tag = "4")] pub writable_layer: ::core::option::Option<FilesystemUsage>,
    }

    #[doc = " CpuUsage provides the CPU usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CpuUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Cumulative CPU usage (sum across all cores) since object creation."]
        #[prost(message, optional, tag = "2")] pub usage_core_nano_seconds: ::core::option::Option<UInt64Value>,
        #[doc = " Total CPU usage (sum of all cores) averaged over the sample window."]
        #[doc = " The \"core\" unit can be interpreted as CPU core-nanoseconds per second."]
        #[prost(message, optional, tag = "3")] pub usage_nano_cores: ::core::option::Option<UInt64Value>,
    }

    #[doc = " MemoryUsage provides the memory usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MemoryUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " The amount of working set memory in bytes."]
        #[prost(message, optional, tag = "2")] pub working_set_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Available memory for use. This is defined as the memory limit - workingSetBytes."]
        #[prost(message, optional, tag = "3")] pub available_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Total memory in use. This includes all memory regardless of when it was accessed."]
        #[prost(message, optional, tag = "4")] pub usage_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " The amount of anonymous and swap cache memory (includes transparent hugepages)."]
        #[prost(message, optional, tag = "5")] pub rss_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative number of minor page faults."]
        #[prost(message, optional, tag = "6")] pub page_faults: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative number of major page faults."]
        #[prost(message, optional, tag = "7")] pub major_page_faults: ::core::option::Option<UInt64Value>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReopenContainerLogRequest {
        #[doc = " ID of the container for which to reopen the log."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReopenContainerLogResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CheckpointContainerRequest {
        #[doc = " ID of the container to be checkpointed."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Location of the checkpoint archive used for export"]
        #[prost(string, tag = "2")] pub location: ::prost::alloc::string::String,
        #[doc = " Timeout in seconds for the checkpoint to complete."]
        #[doc = " Timeout of zero means to use the CRI default."]
        #[doc = " Timeout > 0 means to use the user specified timeout."]
        #[prost(int64, tag = "3")] pub timeout: i64,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CheckpointContainerResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetEventsRequest {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerEventResponse {
        #[doc = " ID of the container"]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Type of the container event"]
        #[prost(enumeration = "ContainerEventType", tag = "2")] pub container_event_type: i32,
        #[doc = " Creation timestamp of this event"]
        #[prost(int64, tag = "3")] pub created_at: i64,
        #[doc = " ID of the sandbox container"]
        #[prost(message, optional, tag = "4")] pub pod_sandbox_metadata: ::core::option::Option<PodSandboxMetadata>,
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Protocol { Tcp = 0, Udp = 1, Sctp = 2 }

    impl Protocol {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Protocol::Tcp => "TCP",
                Protocol::Udp => "UDP",
                Protocol::Sctp => "SCTP",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MountPropagation {
        #[doc = " No mount propagation (\"private\" in Linux terminology)."] PropagationPrivate = 0,
        #[doc = " Mounts get propagated from the host to the container (\"rslave\" in Linux)."] PropagationHostToContainer = 1,
        #[doc = " Mounts get propagated from the host to the container and from the"]
        #[doc = " container to the host (\"rshared\" in Linux)."] PropagationBidirectional = 2,
    }

    impl MountPropagation {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MountPropagation::PropagationPrivate => "PROPAGATION_PRIVATE",
                MountPropagation::PropagationHostToContainer => "PROPAGATION_HOST_TO_CONTAINER",
                MountPropagation::PropagationBidirectional => "PROPAGATION_BIDIRECTIONAL",
            }
        }
    }

    #[doc = " A NamespaceMode describes the intended namespace configuration for each"]
    #[doc = " of the namespaces (Network, PID, IPC) in NamespaceOption. Runtimes should"]
    #[doc = " map these modes as appropriate for the technology underlying the runtime."]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum NamespaceMode {
        #[doc = " A POD namespace is common to all containers in a pod."]
        #[doc = " For example, a container with a PID namespace of POD expects to view"]
        #[doc = " all of the processes in all of the containers in the pod."] Pod = 0,
        #[doc = " A CONTAINER namespace is restricted to a single container."]
        #[doc = " For example, a container with a PID namespace of CONTAINER expects to"]
        #[doc = " view only the processes in that container."] Container = 1,
        #[doc = " A NODE namespace is the namespace of the Kubernetes node."]
        #[doc = " For example, a container with a PID namespace of NODE expects to view"]
        #[doc = " all of the processes on the host running the kubelet."] Node = 2,
        #[doc = " TARGET targets the namespace of another container. When this is specified,"]
        #[doc = " a target_id must be specified in NamespaceOption and refer to a container"]
        #[doc = " previously created with NamespaceMode CONTAINER. This containers namespace"]
        #[doc = " will be made to match that of container target_id."]
        #[doc = " For example, a container with a PID namespace of TARGET expects to view"]
        #[doc = " all of the processes that container target_id can view."] Target = 3,
    }

    impl NamespaceMode {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NamespaceMode::Pod => "POD",
                NamespaceMode::Container => "CONTAINER",
                NamespaceMode::Node => "NODE",
                NamespaceMode::Target => "TARGET",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PodSandboxState { SandboxReady = 0, SandboxNotready = 1 }

    impl PodSandboxState {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PodSandboxState::SandboxReady => "SANDBOX_READY",
                PodSandboxState::SandboxNotready => "SANDBOX_NOTREADY",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ContainerState { ContainerCreated = 0, ContainerRunning = 1, ContainerExited = 2, ContainerUnknown = 3 }

    impl ContainerState {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContainerState::ContainerCreated => "CONTAINER_CREATED",
                ContainerState::ContainerRunning => "CONTAINER_RUNNING",
                ContainerState::ContainerExited => "CONTAINER_EXITED",
                ContainerState::ContainerUnknown => "CONTAINER_UNKNOWN",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ContainerEventType { #[doc = " Container created"] ContainerCreatedEvent = 0, #[doc = " Container started"] ContainerStartedEvent = 1, #[doc = " Container stopped"] ContainerStoppedEvent = 2, #[doc = " Container deleted"] ContainerDeletedEvent = 3 }

    impl ContainerEventType {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContainerEventType::ContainerCreatedEvent => "CONTAINER_CREATED_EVENT",
                ContainerEventType::ContainerStartedEvent => "CONTAINER_STARTED_EVENT",
                ContainerEventType::ContainerStoppedEvent => "CONTAINER_STOPPED_EVENT",
                ContainerEventType::ContainerDeletedEvent => "CONTAINER_DELETED_EVENT",
            }
        }
    }

    #[doc = " Generated server implementations."]
    mod runtime_service_server {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]

        use tonic::codegen::*;

        #[doc = "Generated trait containing gRPC methods that should be implemented for use with RuntimeServiceServer."]
        #[async_trait]
        pub trait RuntimeService: Send + Sync + 'static {
            #[doc = " Version returns the runtime name, runtime version, and runtime API version."]
            async fn version(&self, request: tonic::Request<super::VersionRequest>) -> Result<tonic::Response<super::VersionResponse>, tonic::Status>;
            #[doc = " RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure"]
            #[doc = " the sandbox is in the ready state on success."]
            async fn run_pod_sandbox(&self, request: tonic::Request<super::RunPodSandboxRequest>) -> Result<tonic::Response<super::RunPodSandboxResponse>, tonic::Status>;
            #[doc = " StopPodSandbox stops any running process that is part of the sandbox and"]
            #[doc = " reclaims network resources (e.g., IP addresses) allocated to the sandbox."]
            #[doc = " If there are any running containers in the sandbox, they must be forcibly"]
            #[doc = " terminated."]
            #[doc = " This call is idempotent, and must not return an error if all relevant"]
            #[doc = " resources have already been reclaimed. kubelet will call StopPodSandbox"]
            #[doc = " at least once before calling RemovePodSandbox. It will also attempt to"]
            #[doc = " reclaim resources eagerly, as soon as a sandbox is not needed. Hence,"]
            #[doc = " multiple StopPodSandbox calls are expected."]
            async fn stop_pod_sandbox(&self, request: tonic::Request<super::StopPodSandboxRequest>) -> Result<tonic::Response<super::StopPodSandboxResponse>, tonic::Status>;
            #[doc = " RemovePodSandbox removes the sandbox. If there are any running containers"]
            #[doc = " in the sandbox, they must be forcibly terminated and removed."]
            #[doc = " This call is idempotent, and must not return an error if the sandbox has"]
            #[doc = " already been removed."]
            async fn remove_pod_sandbox(&self, request: tonic::Request<super::RemovePodSandboxRequest>) -> Result<tonic::Response<super::RemovePodSandboxResponse>, tonic::Status>;
            #[doc = " PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not"]
            #[doc = " present, returns an error."]
            async fn pod_sandbox_status(&self, request: tonic::Request<super::PodSandboxStatusRequest>) -> Result<tonic::Response<super::PodSandboxStatusResponse>, tonic::Status>;
            #[doc = " ListPodSandbox returns a list of PodSandboxes."]
            async fn list_pod_sandbox(&self, request: tonic::Request<super::ListPodSandboxRequest>) -> Result<tonic::Response<super::ListPodSandboxResponse>, tonic::Status>;
            #[doc = " CreateContainer creates a new container in specified PodSandbox"]
            async fn create_container(&self, request: tonic::Request<super::CreateContainerRequest>) -> Result<tonic::Response<super::CreateContainerResponse>, tonic::Status>;
            #[doc = " StartContainer starts the container."]
            async fn start_container(&self, request: tonic::Request<super::StartContainerRequest>) -> Result<tonic::Response<super::StartContainerResponse>, tonic::Status>;
            #[doc = " StopContainer stops a running container with a grace period (i.e., timeout)."]
            #[doc = " This call is idempotent, and must not return an error if the container has"]
            #[doc = " already been stopped."]
            #[doc = " The runtime must forcibly kill the container after the grace period is"]
            #[doc = " reached."]
            async fn stop_container(&self, request: tonic::Request<super::StopContainerRequest>) -> Result<tonic::Response<super::StopContainerResponse>, tonic::Status>;
            #[doc = " RemoveContainer removes the container. If the container is running, the"]
            #[doc = " container must be forcibly removed."]
            #[doc = " This call is idempotent, and must not return an error if the container has"]
            #[doc = " already been removed."]
            async fn remove_container(&self, request: tonic::Request<super::RemoveContainerRequest>) -> Result<tonic::Response<super::RemoveContainerResponse>, tonic::Status>;
            #[doc = " ListContainers lists all containers by filters."]
            async fn list_containers(&self, request: tonic::Request<super::ListContainersRequest>) -> Result<tonic::Response<super::ListContainersResponse>, tonic::Status>;
            #[doc = " ContainerStatus returns status of the container. If the container is not"]
            #[doc = " present, returns an error."]
            async fn container_status(&self, request: tonic::Request<super::ContainerStatusRequest>) -> Result<tonic::Response<super::ContainerStatusResponse>, tonic::Status>;
            #[doc = " UpdateContainerResources updates ContainerConfig of the container synchronously."]
            #[doc = " If runtime fails to transactionally update the requested resources, an error is returned."]
            async fn update_container_resources(&self, request: tonic::Request<super::UpdateContainerResourcesRequest>) -> Result<tonic::Response<super::UpdateContainerResourcesResponse>, tonic::Status, >;
            #[doc = " ReopenContainerLog asks runtime to reopen the stdout/stderr log file"]
            #[doc = " for the container. This is often called after the log file has been"]
            #[doc = " rotated. If the container is not running, container runtime can choose"]
            #[doc = " to either create a new log file and return nil, or return an error."]
            #[doc = " Once it returns error, new container log file MUST NOT be created."]
            async fn reopen_container_log(&self, request: tonic::Request<super::ReopenContainerLogRequest>) -> Result<tonic::Response<super::ReopenContainerLogResponse>, tonic::Status>;
            #[doc = " ExecSync runs a command in a container synchronously."]
            async fn exec_sync(&self, request: tonic::Request<super::ExecSyncRequest>) -> Result<tonic::Response<super::ExecSyncResponse>, tonic::Status>;
            #[doc = " Exec prepares a streaming endpoint to execute a command in the container."]
            async fn exec(&self, request: tonic::Request<super::ExecRequest>) -> Result<tonic::Response<super::ExecResponse>, tonic::Status>;
            #[doc = " Attach prepares a streaming endpoint to attach to a running container."]
            async fn attach(&self, request: tonic::Request<super::AttachRequest>) -> Result<tonic::Response<super::AttachResponse>, tonic::Status>;
            #[doc = " PortForward prepares a streaming endpoint to forward ports from a PodSandbox."]
            async fn port_forward(&self, request: tonic::Request<super::PortForwardRequest>) -> Result<tonic::Response<super::PortForwardResponse>, tonic::Status>;
            #[doc = " ContainerStats returns stats of the container. If the container does not"]
            #[doc = " exist, the call returns an error."]
            async fn container_stats(&self, request: tonic::Request<super::ContainerStatsRequest>) -> Result<tonic::Response<super::ContainerStatsResponse>, tonic::Status>;
            #[doc = " ListContainerStats returns stats of all running containers."]
            async fn list_container_stats(&self, request: tonic::Request<super::ListContainerStatsRequest>) -> Result<tonic::Response<super::ListContainerStatsResponse>, tonic::Status>;
            #[doc = " PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not"]
            #[doc = " exist, the call returns an error."]
            async fn pod_sandbox_stats(&self, request: tonic::Request<super::PodSandboxStatsRequest>) -> Result<tonic::Response<super::PodSandboxStatsResponse>, tonic::Status>;
            #[doc = " ListPodSandboxStats returns stats of the pod sandboxes matching a filter."]
            async fn list_pod_sandbox_stats(&self, request: tonic::Request<super::ListPodSandboxStatsRequest>) -> Result<tonic::Response<super::ListPodSandboxStatsResponse>, tonic::Status>;
            #[doc = " UpdateRuntimeConfig updates the runtime configuration based on the given request."]
            async fn update_runtime_config(&self, request: tonic::Request<super::UpdateRuntimeConfigRequest>) -> Result<tonic::Response<super::UpdateRuntimeConfigResponse>, tonic::Status>;
            #[doc = " Status returns the status of the runtime."]
            async fn status(&self, request: tonic::Request<super::StatusRequest>) -> Result<tonic::Response<super::StatusResponse>, tonic::Status>;
            #[doc = " CheckpointContainer checkpoints a container"]
            async fn checkpoint_container(&self, request: tonic::Request<super::CheckpointContainerRequest>) -> Result<tonic::Response<super::CheckpointContainerResponse>, tonic::Status>;
            #[doc = "Server streaming response type for the GetContainerEvents method."]
            type GetContainerEventsStream: futures_core::Stream<Item=Result<super::ContainerEventResponse, tonic::Status>, > + Send + 'static;
            #[doc = " GetContainerEvents gets container events from the CRI runtime"]
            async fn get_container_events(&self, request: tonic::Request<super::GetEventsRequest>) -> Result<tonic::Response<Self::GetContainerEventsStream>, tonic::Status>;
        }

        #[doc = " Runtime service defines the public APIs for remote container runtimes"]
        #[derive(Debug)]
        pub struct RuntimeServiceServer<T: RuntimeService> {
            inner: _Inner<T>,
            accept_compression_encodings: EnabledCompressionEncodings,
            send_compression_encodings: EnabledCompressionEncodings,
        }

        struct _Inner<T>   (Arc<T>);

        impl<T: RuntimeService> RuntimeServiceServer<T> {
            pub fn new(inner: T) -> Self { Self::from_arc(Arc::new(inner)) }
            pub fn from_arc(inner: Arc<T>) -> Self {
                let inner = _Inner(inner);
                Self { inner, accept_compression_encodings: Default::default(), send_compression_encodings: Default::default() }
            }
            pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F> where F: tonic::service::Interceptor, { InterceptedService::new(Self::new(inner), interceptor) }
            #[doc = " Enable decompressing requests with the given encoding."]
            #[must_use]
            pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.accept_compression_encodings.enable(encoding);
                self
            }
            #[doc = " Compress responses with the given encoding, if the client supports it."]
            #[must_use]
            pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.send_compression_encodings.enable(encoding);
                self
            }
        }

        impl<T, B> tonic::codegen::Service<http::Request<B>> for RuntimeServiceServer<T> where T: RuntimeService, B: Body + Send + 'static, B::Error: Into<StdError> + Send + 'static, {
            type Response = http::Response<tonic::body::BoxBody>;
            type Error = std::convert::Infallible;
            type Future = BoxFuture<Self::Response, Self::Error>;
            fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> { Poll::Ready(Ok(())) }
            fn call(&mut self, req: http::Request<B>) -> Self::Future {
                let inner = self.inner.clone();
                match req.uri().path() {
                    "/runtime.v1.RuntimeService/Version" => {
                        #[allow(non_camel_case_types)]
                        struct VersionSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::VersionRequest> for VersionSvc<T> {
                            type Response = super::VersionResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::VersionRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).version(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = VersionSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/RunPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct RunPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RunPodSandboxRequest> for RunPodSandboxSvc<T> {
                            type Response = super::RunPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RunPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).run_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RunPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/StopPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct StopPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StopPodSandboxRequest> for StopPodSandboxSvc<T> {
                            type Response = super::StopPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StopPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).stop_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StopPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/RemovePodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct RemovePodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RemovePodSandboxRequest> for RemovePodSandboxSvc<T> {
                            type Response = super::RemovePodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemovePodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemovePodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/PodSandboxStatus" => {
                        #[allow(non_camel_case_types)]
                        struct PodSandboxStatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PodSandboxStatusRequest> for PodSandboxStatusSvc<T> {
                            type Response = super::PodSandboxStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PodSandboxStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pod_sandbox_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PodSandboxStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ListPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct ListPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListPodSandboxRequest> for ListPodSandboxSvc<T> {
                            type Response = super::ListPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/CreateContainer" => {
                        #[allow(non_camel_case_types)]
                        struct CreateContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::CreateContainerRequest> for CreateContainerSvc<T> {
                            type Response = super::CreateContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::CreateContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).create_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = CreateContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/StartContainer" => {
                        #[allow(non_camel_case_types)]
                        struct StartContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StartContainerRequest> for StartContainerSvc<T> {
                            type Response = super::StartContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StartContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).start_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StartContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/StopContainer" => {
                        #[allow(non_camel_case_types)]
                        struct StopContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StopContainerRequest> for StopContainerSvc<T> {
                            type Response = super::StopContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StopContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).stop_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StopContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/RemoveContainer" => {
                        #[allow(non_camel_case_types)]
                        struct RemoveContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RemoveContainerRequest> for RemoveContainerSvc<T> {
                            type Response = super::RemoveContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemoveContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemoveContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ListContainers" => {
                        #[allow(non_camel_case_types)]
                        struct ListContainersSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListContainersRequest> for ListContainersSvc<T> {
                            type Response = super::ListContainersResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListContainersRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_containers(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListContainersSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ContainerStatus" => {
                        #[allow(non_camel_case_types)]
                        struct ContainerStatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ContainerStatusRequest> for ContainerStatusSvc<T> {
                            type Response = super::ContainerStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ContainerStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).container_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ContainerStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/UpdateContainerResources" => {
                        #[allow(non_camel_case_types)]
                        struct UpdateContainerResourcesSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::UpdateContainerResourcesRequest> for UpdateContainerResourcesSvc<T> {
                            type Response = super::UpdateContainerResourcesResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::UpdateContainerResourcesRequest, >) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).update_container_resources(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = UpdateContainerResourcesSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ReopenContainerLog" => {
                        #[allow(non_camel_case_types)]
                        struct ReopenContainerLogSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ReopenContainerLogRequest> for ReopenContainerLogSvc<T> {
                            type Response = super::ReopenContainerLogResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ReopenContainerLogRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).reopen_container_log(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ReopenContainerLogSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ExecSync" => {
                        #[allow(non_camel_case_types)]
                        struct ExecSyncSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ExecSyncRequest> for ExecSyncSvc<T> {
                            type Response = super::ExecSyncResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ExecSyncRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).exec_sync(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ExecSyncSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/Exec" => {
                        #[allow(non_camel_case_types)]
                        struct ExecSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ExecRequest> for ExecSvc<T> {
                            type Response = super::ExecResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ExecRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).exec(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ExecSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/Attach" => {
                        #[allow(non_camel_case_types)]
                        struct AttachSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::AttachRequest> for AttachSvc<T> {
                            type Response = super::AttachResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::AttachRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).attach(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = AttachSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/PortForward" => {
                        #[allow(non_camel_case_types)]
                        struct PortForwardSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PortForwardRequest> for PortForwardSvc<T> {
                            type Response = super::PortForwardResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PortForwardRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).port_forward(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PortForwardSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ContainerStats" => {
                        #[allow(non_camel_case_types)]
                        struct ContainerStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ContainerStatsRequest> for ContainerStatsSvc<T> {
                            type Response = super::ContainerStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ContainerStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).container_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ContainerStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ListContainerStats" => {
                        #[allow(non_camel_case_types)]
                        struct ListContainerStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListContainerStatsRequest> for ListContainerStatsSvc<T> {
                            type Response = super::ListContainerStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListContainerStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_container_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListContainerStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/PodSandboxStats" => {
                        #[allow(non_camel_case_types)]
                        struct PodSandboxStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PodSandboxStatsRequest> for PodSandboxStatsSvc<T> {
                            type Response = super::PodSandboxStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PodSandboxStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pod_sandbox_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PodSandboxStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/ListPodSandboxStats" => {
                        #[allow(non_camel_case_types)]
                        struct ListPodSandboxStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListPodSandboxStatsRequest> for ListPodSandboxStatsSvc<T> {
                            type Response = super::ListPodSandboxStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListPodSandboxStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_pod_sandbox_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListPodSandboxStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/UpdateRuntimeConfig" => {
                        #[allow(non_camel_case_types)]
                        struct UpdateRuntimeConfigSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::UpdateRuntimeConfigRequest> for UpdateRuntimeConfigSvc<T> {
                            type Response = super::UpdateRuntimeConfigResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::UpdateRuntimeConfigRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).update_runtime_config(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = UpdateRuntimeConfigSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/Status" => {
                        #[allow(non_camel_case_types)]
                        struct StatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StatusRequest> for StatusSvc<T> {
                            type Response = super::StatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/CheckpointContainer" => {
                        #[allow(non_camel_case_types)]
                        struct CheckpointContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::CheckpointContainerRequest> for CheckpointContainerSvc<T> {
                            type Response = super::CheckpointContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::CheckpointContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).checkpoint_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = CheckpointContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.RuntimeService/GetContainerEvents" => {
                        #[allow(non_camel_case_types)]
                        struct GetContainerEventsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::ServerStreamingService<super::GetEventsRequest> for GetContainerEventsSvc<T> {
                            type Response = super::ContainerEventResponse;
                            type ResponseStream = T::GetContainerEventsStream;
                            type Future = BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::GetEventsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).get_container_events(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = GetContainerEventsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.server_streaming(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    _ => { Box::pin(async move { Ok(http::Response::builder().status(200).header("grpc-status", "12").header("content-type", "application/grpc").body(empty_body()).unwrap()) }) }
                }
            }
        }

        impl<T: RuntimeService> Clone for RuntimeServiceServer<T> {
            fn clone(&self) -> Self {
                let inner = self.inner.clone();
                Self { inner, accept_compression_encodings: self.accept_compression_encodings, send_compression_encodings: self.send_compression_encodings }
            }
        }

        impl<T: RuntimeService> Clone for _Inner<T> { fn clone(&self) -> Self { Self(self.0.clone()) } }

        impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { f.write_fmt(IntellijRustDollarCrate::format_args!("{:?}", self.0)) } }

        impl<T: RuntimeService> tonic::server::NamedService for RuntimeServiceServer<T> { const NAME: &'static str = "runtime.v1.RuntimeService"; }
    }

    #[doc = " Generated server implementations."]
    pub mod image_service_server {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]

        use tonic::codegen::*;

        #[doc = "Generated trait containing gRPC methods that should be implemented for use with ImageServiceServer."]
        #[async_trait]
        pub trait ImageService: Send + Sync + 'static {
            #[doc = " ListImages lists existing images."]
            async fn list_images(&self, request: tonic::Request<super::ListImagesRequest>) -> Result<tonic::Response<super::ListImagesResponse>, tonic::Status>;
            #[doc = " ImageStatus returns the status of the image. If the image is not"]
            #[doc = " present, returns a response with ImageStatusResponse.Image set to"]
            #[doc = " nil."]
            async fn image_status(&self, request: tonic::Request<super::ImageStatusRequest>) -> Result<tonic::Response<super::ImageStatusResponse>, tonic::Status>;
            #[doc = " PullImage pulls an image with authentication config."]
            async fn pull_image(&self, request: tonic::Request<super::PullImageRequest>) -> Result<tonic::Response<super::PullImageResponse>, tonic::Status>;
            #[doc = " RemoveImage removes the image."]
            #[doc = " This call is idempotent, and must not return an error if the image has"]
            #[doc = " already been removed."]
            async fn remove_image(&self, request: tonic::Request<super::RemoveImageRequest>) -> Result<tonic::Response<super::RemoveImageResponse>, tonic::Status>;
            #[doc = " ImageFSInfo returns information of the filesystem that is used to store images."]
            async fn image_fs_info(&self, request: tonic::Request<super::ImageFsInfoRequest>) -> Result<tonic::Response<super::ImageFsInfoResponse>, tonic::Status>;
        }

        #[doc = " ImageService defines the public APIs for managing images."]
        #[derive(Debug)]
        pub struct ImageServiceServer<T: ImageService> {
            inner: _Inner<T>,
            accept_compression_encodings: EnabledCompressionEncodings,
            send_compression_encodings: EnabledCompressionEncodings,
        }

        struct _Inner<T>   (Arc<T>);

        impl<T: ImageService> ImageServiceServer<T> {
            pub fn new(inner: T) -> Self { Self::from_arc(Arc::new(inner)) }
            pub fn from_arc(inner: Arc<T>) -> Self {
                let inner = _Inner(inner);
                Self { inner, accept_compression_encodings: Default::default(), send_compression_encodings: Default::default() }
            }
            pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F> where F: tonic::service::Interceptor, { InterceptedService::new(Self::new(inner), interceptor) }
            #[doc = " Enable decompressing requests with the given encoding."]
            #[must_use]
            pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.accept_compression_encodings.enable(encoding);
                self
            }
            #[doc = " Compress responses with the given encoding, if the client supports it."]
            #[must_use]
            pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.send_compression_encodings.enable(encoding);
                self
            }
        }

        impl<T, B> tonic::codegen::Service<http::Request<B>> for ImageServiceServer<T> where T: ImageService, B: Body + Send + 'static, B::Error: Into<StdError> + Send + 'static, {
            type Response = http::Response<tonic::body::BoxBody>;
            type Error = std::convert::Infallible;
            type Future = BoxFuture<Self::Response, Self::Error>;
            fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> { Poll::Ready(Ok(())) }
            fn call(&mut self, req: http::Request<B>) -> Self::Future {
                let inner = self.inner.clone();
                match req.uri().path() {
                    "/runtime.v1.ImageService/ListImages" => {
                        #[allow(non_camel_case_types)]
                        struct ListImagesSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ListImagesRequest> for ListImagesSvc<T> {
                            type Response = super::ListImagesResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListImagesRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_images(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListImagesSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.ImageService/ImageStatus" => {
                        #[allow(non_camel_case_types)]
                        struct ImageStatusSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ImageStatusRequest> for ImageStatusSvc<T> {
                            type Response = super::ImageStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ImageStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).image_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ImageStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.ImageService/PullImage" => {
                        #[allow(non_camel_case_types)]
                        struct PullImageSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::PullImageRequest> for PullImageSvc<T> {
                            type Response = super::PullImageResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PullImageRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pull_image(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PullImageSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.ImageService/RemoveImage" => {
                        #[allow(non_camel_case_types)]
                        struct RemoveImageSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::RemoveImageRequest> for RemoveImageSvc<T> {
                            type Response = super::RemoveImageResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemoveImageRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_image(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemoveImageSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1.ImageService/ImageFsInfo" => {
                        #[allow(non_camel_case_types)]
                        struct ImageFsInfoSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ImageFsInfoRequest> for ImageFsInfoSvc<T> {
                            type Response = super::ImageFsInfoResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ImageFsInfoRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).image_fs_info(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ImageFsInfoSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    _ => { Box::pin(async move { Ok(http::Response::builder().status(200).header("grpc-status", "12").header("content-type", "application/grpc").body(empty_body()).unwrap()) }) }
                }
            }
        }

        impl<T: ImageService> Clone for ImageServiceServer<T> {
            fn clone(&self) -> Self {
                let inner = self.inner.clone();
                Self { inner, accept_compression_encodings: self.accept_compression_encodings, send_compression_encodings: self.send_compression_encodings }
            }
        }

        impl<T: ImageService> Clone for _Inner<T> { fn clone(&self) -> Self { Self(self.0.clone()) } }

        impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { f.write_fmt(IntellijRustDollarCrate::format_args!("{:?}", self.0)) } }

        impl<T: ImageService> tonic::server::NamedService for ImageServiceServer<T> { const NAME: &'static str = "runtime.v1.ImageService"; }
    }

    #[tonic::async_trait]
    impl super::ImageService_v1 for super::Square {
        #[doc = " ListImages lists existing images."]
        async fn list_images(&self, request: tonic::Request<ListImagesRequest>) -> Result<tonic::Response<ListImagesResponse>, tonic::Status> { self.list_images(request).await }
        #[doc = " ImageStatus returns the status of the image. If the image is not"]
        #[doc = " present, returns a response with ImageStatusResponse.Image set to"]
        #[doc = " nil."]
        async fn image_status(&self, request: tonic::Request<ImageStatusRequest>) -> Result<tonic::Response<ImageStatusResponse>, tonic::Status> { self.image_status(request).await }
        #[doc = " PullImage pulls an image with authentication config."]
        async fn pull_image(&self, request: tonic::Request<PullImageRequest>) -> Result<tonic::Response<PullImageResponse>, tonic::Status> { self.pull_image(request).await }
        #[doc = " RemoveImage removes the image."]
        #[doc = " This call is idempotent, and must not return an error if the image has"]
        #[doc = " already been removed."]
        async fn remove_image(&self, request: tonic::Request<RemoveImageRequest>) -> Result<tonic::Response<RemoveImageResponse>, tonic::Status> { self.remove_image(request).await }
        #[doc = " ImageFSInfo returns information of the filesystem that is used to store images."]
        async fn image_fs_info(&self, request: tonic::Request<ImageFsInfoRequest>) -> Result<tonic::Response<ImageFsInfoResponse>, tonic::Status> { self.image_fs_info(request).await }
    }
}
use image_service_server::ImageService   as ImageService_v1;
#[doc = "Version v1alpha2 Impls generated by auto_impl"]
pub mod v1alpha2 {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionRequest {
        #[doc = " Version of the kubelet runtime API."]
        #[prost(string, tag = "1")] pub version: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionResponse {
        #[doc = " Version of the kubelet runtime API."]
        #[prost(string, tag = "1")] pub version: ::prost::alloc::string::String,
        #[doc = " Name of the container runtime."]
        #[prost(string, tag = "2")] pub runtime_name: ::prost::alloc::string::String,
        #[doc = " Version of the container runtime. The string must be"]
        #[doc = " semver-compatible."]
        #[prost(string, tag = "3")] pub runtime_version: ::prost::alloc::string::String,
        #[doc = " API version of the container runtime. The string must be"]
        #[doc = " semver-compatible."]
        #[prost(string, tag = "4")] pub runtime_api_version: ::prost::alloc::string::String,
    }

    #[doc = " DNSConfig specifies the DNS servers and search domains of a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DnsConfig {
        #[doc = " List of DNS servers of the cluster."]
        #[prost(string, repeated, tag = "1")] pub servers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of DNS search domains of the cluster."]
        #[prost(string, repeated, tag = "2")] pub searches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of DNS options. See <https://linux.die.net/man/5/resolv.conf>"]
        #[doc = " for all available options."]
        #[prost(string, repeated, tag = "3")] pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }

    #[doc = " PortMapping specifies the port mapping configurations of a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortMapping {
        #[doc = " Protocol of the port mapping."]
        #[prost(enumeration = "Protocol", tag = "1")] pub protocol: i32,
        #[doc = " Port number within the container. Default: 0 (not specified)."]
        #[prost(int32, tag = "2")] pub container_port: i32,
        #[doc = " Port number on the host. Default: 0 (not specified)."]
        #[prost(int32, tag = "3")] pub host_port: i32,
        #[doc = " Host IP."]
        #[prost(string, tag = "4")] pub host_ip: ::prost::alloc::string::String,
    }

    #[doc = " Mount specifies a host volume to mount into a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Mount {
        #[doc = " Path of the mount within the container."]
        #[prost(string, tag = "1")] pub container_path: ::prost::alloc::string::String,
        #[doc = " Path of the mount on the host. If the hostPath doesn\'t exist, then runtimes"]
        #[doc = " should report error. If the hostpath is a symbolic link, runtimes should"]
        #[doc = " follow the symlink and mount the real destination to container."]
        #[prost(string, tag = "2")] pub host_path: ::prost::alloc::string::String,
        #[doc = " If set, the mount is read-only."]
        #[prost(bool, tag = "3")] pub readonly: bool,
        #[doc = " If set, the mount needs SELinux relabeling."]
        #[prost(bool, tag = "4")] pub selinux_relabel: bool,
        #[doc = " Requested propagation mode."]
        #[prost(enumeration = "MountPropagation", tag = "5")] pub propagation: i32,
    }

    #[doc = " IDMapping describes host to container ID mappings for a pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdMapping {
        #[doc = " HostId is the id on the host."]
        #[prost(uint32, tag = "1")] pub host_id: u32,
        #[doc = " ContainerId is the id in the container."]
        #[prost(uint32, tag = "2")] pub container_id: u32,
        #[doc = " Length is the size of the range to map."]
        #[prost(uint32, tag = "3")] pub length: u32,
    }

    #[doc = " UserNamespace describes the intended user namespace configuration for a pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserNamespace {
        #[doc = " Mode is the NamespaceMode for this UserNamespace."]
        #[doc = " Note: NamespaceMode for UserNamespace currently supports only POD and NODE, not CONTAINER OR TARGET."]
        #[prost(enumeration = "NamespaceMode", tag = "1")] pub mode: i32,
        #[doc = " Uids specifies the UID mappings for the user namespace."]
        #[prost(message, repeated, tag = "2")] pub uids: ::prost::alloc::vec::Vec<IdMapping>,
        #[doc = " Gids specifies the GID mappings for the user namespace."]
        #[prost(message, repeated, tag = "3")] pub gids: ::prost::alloc::vec::Vec<IdMapping>,
    }

    #[doc = " NamespaceOption provides options for Linux namespaces."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NamespaceOption {
        #[doc = " Network namespace for this container/sandbox."]
        #[doc = " Note: There is currently no way to set CONTAINER scoped network in the Kubernetes API."]
        #[doc = " Namespaces currently set by the kubelet: POD, NODE"]
        #[prost(enumeration = "NamespaceMode", tag = "1")] pub network: i32,
        #[doc = " PID namespace for this container/sandbox."]
        #[doc = " Note: The CRI default is POD, but the v1.PodSpec default is CONTAINER."]
        #[doc = " The kubelet\'s runtime manager will set this to CONTAINER explicitly for v1 pods."]
        #[doc = " Namespaces currently set by the kubelet: POD, CONTAINER, NODE, TARGET"]
        #[prost(enumeration = "NamespaceMode", tag = "2")] pub pid: i32,
        #[doc = " IPC namespace for this container/sandbox."]
        #[doc = " Note: There is currently no way to set CONTAINER scoped IPC in the Kubernetes API."]
        #[doc = " Namespaces currently set by the kubelet: POD, NODE"]
        #[prost(enumeration = "NamespaceMode", tag = "3")] pub ipc: i32,
        #[doc = " Target Container ID for NamespaceMode of TARGET. This container must have been"]
        #[doc = " previously created in the same pod. It is not possible to specify different targets"]
        #[doc = " for each namespace."]
        #[prost(string, tag = "4")] pub target_id: ::prost::alloc::string::String,
        #[doc = " UsernsOptions for this pod sandbox."]
        #[doc = " The Kubelet picks the user namespace configuration to use for the pod sandbox.  The mappings"]
        #[doc = " are specified as part of the UserNamespace struct.  If the struct is nil, then the POD mode"]
        #[doc = " must be assumed.  This is done for backward compatibility with older Kubelet versions that"]
        #[doc = " do not set a user namespace."]
        #[prost(message, optional, tag = "5")] pub userns_options: ::core::option::Option<UserNamespace>,
    }

    #[doc = " Int64Value is the wrapper of int64."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Int64Value {
        #[doc = " The value."]
        #[prost(int64, tag = "1")] pub value: i64,
    }

    #[doc = " LinuxSandboxSecurityContext holds linux security configuration that will be"]
    #[doc = " applied to a sandbox. Note that:"]
    #[doc = " 1) It does not apply to containers in the pods."]
    #[doc = " 2) It may not be applicable to a PodSandbox which does not contain any running"]
    #[doc = "     process."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxSandboxSecurityContext {
        #[doc = " Configurations for the sandbox\'s namespaces."]
        #[doc = " This will be used only if the PodSandbox uses namespace for isolation."]
        #[prost(message, optional, tag = "1")] pub namespace_options: ::core::option::Option<NamespaceOption>,
        #[doc = " Optional SELinux context to be applied."]
        #[prost(message, optional, tag = "2")] pub selinux_options: ::core::option::Option<SeLinuxOption>,
        #[doc = " UID to run sandbox processes as, when applicable."]
        #[prost(message, optional, tag = "3")] pub run_as_user: ::core::option::Option<Int64Value>,
        #[doc = " GID to run sandbox processes as, when applicable. run_as_group should only"]
        #[doc = " be specified when run_as_user is specified; otherwise, the runtime MUST error."]
        #[prost(message, optional, tag = "8")] pub run_as_group: ::core::option::Option<Int64Value>,
        #[doc = " If set, the root filesystem of the sandbox is read-only."]
        #[prost(bool, tag = "4")] pub readonly_rootfs: bool,
        #[doc = " List of groups applied to the first process run in the sandbox, in"]
        #[doc = " addition to the sandbox\'s primary GID."]
        #[prost(int64, repeated, tag = "5")] pub supplemental_groups: ::prost::alloc::vec::Vec<i64>,
        #[doc = " Indicates whether the sandbox will be asked to run a privileged"]
        #[doc = " container. If a privileged container is to be executed within it, this"]
        #[doc = " MUST be true."]
        #[doc = " This allows a sandbox to take additional security precautions if no"]
        #[doc = " privileged containers are expected to be run."]
        #[prost(bool, tag = "6")] pub privileged: bool,
        #[doc = " Seccomp profile for the sandbox."]
        #[prost(message, optional, tag = "9")] pub seccomp: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the sandbox."]
        #[prost(message, optional, tag = "10")] pub apparmor: ::core::option::Option<SecurityProfile>,
        #[doc = " Seccomp profile for the sandbox, candidate values are:"]
        #[doc = " * runtime/default: the default profile for the container runtime"]
        #[doc = " * unconfined: unconfined profile, ie, no seccomp sandboxing"]
        #[doc = " * localhost/<full-path-to-profile>: the profile installed on the node."]
        #[doc = "    <full-path-to-profile> is the full path of the profile."]
        #[doc = " Default: \"\", which is identical with unconfined."]
        #[deprecated]
        #[prost(string, tag = "7")] pub seccomp_profile_path: ::prost::alloc::string::String,
    }

    #[doc = " A security profile which can be used for sandboxes and containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityProfile {
        #[doc = " Indicator which `ProfileType` should be applied."]
        #[prost(enumeration = "security_profile::ProfileType", tag = "1")] pub profile_type: i32,
        #[doc = " Indicates that a pre-defined profile on the node should be used."]
        #[doc = " Must only be set if `ProfileType` is `Localhost`."]
        #[doc = " For seccomp, it must be an absolute path to the seccomp profile."]
        #[doc = " For AppArmor, this field is the AppArmor `<profile name>/`"]
        #[prost(string, tag = "2")] pub localhost_ref: ::prost::alloc::string::String,
    }

    #[doc = " Nested message and enum types in `SecurityProfile`."]
    pub mod security_profile {
        #[doc = " Available profile types."]
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ProfileType { #[doc = " The container runtime default profile should be used."] RuntimeDefault = 0, #[doc = " Disable the feature for the sandbox or the container."] Unconfined = 1, #[doc = " A pre-defined profile on the node should be used."] Localhost = 2 }

        impl ProfileType {
            #[doc = " String value of the enum field names used in the ProtoBuf definition."]
            #[doc = ""]
            #[doc = " The values are not transformed in any way and thus are considered stable"]
            #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ProfileType::RuntimeDefault => "RuntimeDefault",
                    ProfileType::Unconfined => "Unconfined",
                    ProfileType::Localhost => "Localhost",
                }
            }
        }
    }

    #[doc = " LinuxPodSandboxConfig holds platform-specific configurations for Linux"]
    #[doc = " host platforms and Linux-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxConfig {
        #[doc = " Parent cgroup of the PodSandbox."]
        #[doc = " The cgroupfs style syntax will be used, but the container runtime can"]
        #[doc = " convert it to systemd semantics if needed."]
        #[prost(string, tag = "1")] pub cgroup_parent: ::prost::alloc::string::String,
        #[doc = " LinuxSandboxSecurityContext holds sandbox security attributes."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<LinuxSandboxSecurityContext>,
        #[doc = " Sysctls holds linux sysctls config for the sandbox."]
        #[prost(map = "string, string", tag = "3")] pub sysctls: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Optional overhead represents the overheads associated with this sandbox"]
        #[prost(message, optional, tag = "4")] pub overhead: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Optional resources represents the sum of container resources for this sandbox"]
        #[prost(message, optional, tag = "5")] pub resources: ::core::option::Option<LinuxContainerResources>,
    }

    #[doc = " PodSandboxMetadata holds all necessary information for building the sandbox name."]
    #[doc = " The container runtime is encouraged to expose the metadata associated with the"]
    #[doc = " PodSandbox in its user interface for better user experience. For example,"]
    #[doc = " the runtime can construct a unique PodSandboxName based on the metadata."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxMetadata {
        #[doc = " Pod name of the sandbox. Same as the pod name in the Pod ObjectMeta."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Pod UID of the sandbox. Same as the pod UID in the Pod ObjectMeta."]
        #[prost(string, tag = "2")] pub uid: ::prost::alloc::string::String,
        #[doc = " Pod namespace of the sandbox. Same as the pod namespace in the Pod ObjectMeta."]
        #[prost(string, tag = "3")] pub namespace: ::prost::alloc::string::String,
        #[doc = " Attempt number of creating the sandbox. Default: 0."]
        #[prost(uint32, tag = "4")] pub attempt: u32,
    }

    #[doc = " PodSandboxConfig holds all the required and optional fields for creating a"]
    #[doc = " sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxConfig {
        #[doc = " Metadata of the sandbox. This information will uniquely identify the"]
        #[doc = " sandbox, and the runtime should leverage this to ensure correct"]
        #[doc = " operation. The runtime may also use this information to improve UX, such"]
        #[doc = " as by constructing a readable name."]
        #[prost(message, optional, tag = "1")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " Hostname of the sandbox. Hostname could only be empty when the pod"]
        #[doc = " network namespace is NODE."]
        #[prost(string, tag = "2")] pub hostname: ::prost::alloc::string::String,
        #[doc = " Path to the directory on the host in which container log files are"]
        #[doc = " stored."]
        #[doc = " By default the log of a container going into the LogDirectory will be"]
        #[doc = " hooked up to STDOUT and STDERR. However, the LogDirectory may contain"]
        #[doc = " binary log files with structured logging data from the individual"]
        #[doc = " containers. For example, the files might be newline separated JSON"]
        #[doc = " structured logs, systemd-journald journal files, gRPC trace files, etc."]
        #[doc = " E.g.,"]
        #[doc = "      PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`"]
        #[doc = "      ContainerConfig.LogPath = `containerName/Instance#.log`"]
        #[prost(string, tag = "3")] pub log_directory: ::prost::alloc::string::String,
        #[doc = " DNS config for the sandbox."]
        #[prost(message, optional, tag = "4")] pub dns_config: ::core::option::Option<DnsConfig>,
        #[doc = " Port mappings for the sandbox."]
        #[prost(message, repeated, tag = "5")] pub port_mappings: ::prost::alloc::vec::Vec<PortMapping>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "6")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map that may be set by the kubelet to store and"]
        #[doc = " retrieve arbitrary metadata. This will include any annotations set on a"]
        #[doc = " pod through the Kubernetes API."]
        #[doc = ""]
        #[doc = " Annotations MUST NOT be altered by the runtime; the annotations stored"]
        #[doc = " here MUST be returned in the PodSandboxStatus associated with the pod"]
        #[doc = " this PodSandboxConfig creates."]
        #[doc = ""]
        #[doc = " In general, in order to preserve a well-defined interface between the"]
        #[doc = " kubelet and the container runtime, annotations SHOULD NOT influence"]
        #[doc = " runtime behaviour."]
        #[doc = ""]
        #[doc = " Annotations can also be useful for runtime authors to experiment with"]
        #[doc = " new features that are opaque to the Kubernetes APIs (both user-facing"]
        #[doc = " and the CRI). Whenever possible, however, runtime authors SHOULD"]
        #[doc = " consider proposing new typed fields for any new features instead."]
        #[prost(map = "string, string", tag = "7")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Optional configurations specific to Linux hosts."]
        #[prost(message, optional, tag = "8")] pub linux: ::core::option::Option<LinuxPodSandboxConfig>,
        #[doc = " Optional configurations specific to Windows hosts."]
        #[prost(message, optional, tag = "9")] pub windows: ::core::option::Option<WindowsPodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunPodSandboxRequest {
        #[doc = " Configuration for creating a PodSandbox."]
        #[prost(message, optional, tag = "1")] pub config: ::core::option::Option<PodSandboxConfig>,
        #[doc = " Named runtime configuration to use for this PodSandbox."]
        #[doc = " If the runtime handler is unknown, this request should be rejected.  An"]
        #[doc = " empty string should select the default handler, equivalent to the"]
        #[doc = " behavior before this feature was added."]
        #[doc = " See <https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class>"]
        #[prost(string, tag = "2")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunPodSandboxResponse {
        #[doc = " ID of the PodSandbox to run."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopPodSandboxRequest {
        #[doc = " ID of the PodSandbox to stop."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopPodSandboxResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemovePodSandboxRequest {
        #[doc = " ID of the PodSandbox to remove."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemovePodSandboxResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatusRequest {
        #[doc = " ID of the PodSandbox for which to retrieve status."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Verbose indicates whether to return extra information about the pod sandbox."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[doc = " PodIP represents an ip of a Pod"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodIp {
        #[doc = " an ip is a string representation of an IPv4 or an IPv6"]
        #[prost(string, tag = "1")] pub ip: ::prost::alloc::string::String,
    }

    #[doc = " PodSandboxNetworkStatus is the status of the network for a PodSandbox."]
    #[doc = " Currently ignored for pods sharing the host networking namespace."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxNetworkStatus {
        #[doc = " IP address of the PodSandbox."]
        #[prost(string, tag = "1")] pub ip: ::prost::alloc::string::String,
        #[doc = " list of additional ips (not inclusive of PodSandboxNetworkStatus.Ip) of the PodSandBoxNetworkStatus"]
        #[prost(message, repeated, tag = "2")] pub additional_ips: ::prost::alloc::vec::Vec<PodIp>,
    }

    #[doc = " Namespace contains paths to the namespaces."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Namespace {
        #[doc = " Namespace options for Linux namespaces."]
        #[prost(message, optional, tag = "2")] pub options: ::core::option::Option<NamespaceOption>,
    }

    #[doc = " LinuxSandboxStatus contains status specific to Linux sandboxes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxStatus {
        #[doc = " Paths to the sandbox\'s namespaces."]
        #[prost(message, optional, tag = "1")] pub namespaces: ::core::option::Option<Namespace>,
    }

    #[doc = " PodSandboxStatus contains the status of the PodSandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatus {
        #[doc = " ID of the sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the sandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " State of the sandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "3")] pub state: i32,
        #[doc = " Creation timestamp of the sandbox in nanoseconds. Must be > 0."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Network contains network status if network is handled by the runtime."]
        #[prost(message, optional, tag = "5")] pub network: ::core::option::Option<PodSandboxNetworkStatus>,
        #[doc = " Linux-specific status to a pod sandbox."]
        #[prost(message, optional, tag = "6")] pub linux: ::core::option::Option<LinuxPodSandboxStatus>,
        #[doc = " Labels are key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "7")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxConfig used to"]
        #[doc = " instantiate the pod sandbox this status represents."]
        #[prost(map = "string, string", tag = "8")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " runtime configuration used for this PodSandbox."]
        #[prost(string, tag = "9")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatusResponse {
        #[doc = " Status of the PodSandbox."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<PodSandboxStatus>,
        #[doc = " Info is extra information of the PodSandbox. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. network namespace for linux container based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " PodSandboxStateValue is the wrapper of PodSandboxState."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStateValue {
        #[doc = " State of the sandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "1")] pub state: i32,
    }

    #[doc = " PodSandboxFilter is used to filter a list of PodSandboxes."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxFilter {
        #[doc = " ID of the sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " State of the sandbox."]
        #[prost(message, optional, tag = "2")] pub state: ::core::option::Option<PodSandboxStateValue>,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "3")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxRequest {
        #[doc = " PodSandboxFilter to filter a list of PodSandboxes."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<PodSandboxFilter>,
    }

    #[doc = " PodSandbox contains minimal information about a sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandbox {
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the PodSandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " State of the PodSandbox."]
        #[prost(enumeration = "PodSandboxState", tag = "3")] pub state: i32,
        #[doc = " Creation timestamps of the PodSandbox in nanoseconds. Must be > 0."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Labels of the PodSandbox."]
        #[prost(map = "string, string", tag = "5")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxConfig used to"]
        #[doc = " instantiate this PodSandbox."]
        #[prost(map = "string, string", tag = "6")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " runtime configuration used for this PodSandbox."]
        #[prost(string, tag = "7")] pub runtime_handler: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxResponse {
        #[doc = " List of PodSandboxes."]
        #[prost(message, repeated, tag = "1")] pub items: ::prost::alloc::vec::Vec<PodSandbox>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsRequest {
        #[doc = " ID of the pod sandbox for which to retrieve stats."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsResponse {
        #[prost(message, optional, tag = "1")] pub stats: ::core::option::Option<PodSandboxStats>,
    }

    #[doc = " PodSandboxStatsFilter is used to filter the list of pod sandboxes to retrieve stats for."]
    #[doc = " All those fields are combined with \'AND\'."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStatsFilter {
        #[doc = " ID of the pod sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "2")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxStatsRequest {
        #[doc = " Filter for the list request."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<PodSandboxStatsFilter>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListPodSandboxStatsResponse {
        #[doc = " Stats of the pod sandbox."]
        #[prost(message, repeated, tag = "1")] pub stats: ::prost::alloc::vec::Vec<PodSandboxStats>,
    }

    #[doc = " PodSandboxAttributes provides basic information of the pod sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxAttributes {
        #[doc = " ID of the pod sandbox."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the pod sandbox."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<PodSandboxMetadata>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "3")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding PodSandboxStatus used to"]
        #[doc = " instantiate the PodSandbox this status represents."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " PodSandboxStats provides the resource usage statistics for a pod."]
    #[doc = " The linux or windows field will be populated depending on the platform."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PodSandboxStats {
        #[doc = " Information of the pod."]
        #[prost(message, optional, tag = "1")] pub attributes: ::core::option::Option<PodSandboxAttributes>,
        #[doc = " Stats from linux."]
        #[prost(message, optional, tag = "2")] pub linux: ::core::option::Option<LinuxPodSandboxStats>,
        #[doc = " Stats from windows."]
        #[prost(message, optional, tag = "3")] pub windows: ::core::option::Option<WindowsPodSandboxStats>,
    }

    #[doc = " LinuxPodSandboxStats provides the resource usage statistics for a pod sandbox on linux."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxPodSandboxStats {
        #[doc = " CPU usage gathered for the pod sandbox."]
        #[prost(message, optional, tag = "1")] pub cpu: ::core::option::Option<CpuUsage>,
        #[doc = " Memory usage gathered for the pod sandbox."]
        #[prost(message, optional, tag = "2")] pub memory: ::core::option::Option<MemoryUsage>,
        #[doc = " Network usage gathered for the pod sandbox"]
        #[prost(message, optional, tag = "3")] pub network: ::core::option::Option<NetworkUsage>,
        #[doc = " Stats pertaining to processes in the pod sandbox."]
        #[prost(message, optional, tag = "4")] pub process: ::core::option::Option<ProcessUsage>,
        #[doc = " Stats of containers in the measured pod sandbox."]
        #[prost(message, repeated, tag = "5")] pub containers: ::prost::alloc::vec::Vec<ContainerStats>,
    }

    #[doc = " WindowsPodSandboxStats provides the resource usage statistics for a pod sandbox on windows"]
    #[doc = ""]
    #[doc = " TODO: Add stats relevant to windows."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsPodSandboxStats {}

    #[doc = " NetworkUsage contains data about network resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkUsage {
        #[doc = " The time at which these stats were updated."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Stats for the default network interface."]
        #[prost(message, optional, tag = "2")] pub default_interface: ::core::option::Option<NetworkInterfaceUsage>,
        #[doc = " Stats for all found network interfaces, excluding the default."]
        #[prost(message, repeated, tag = "3")] pub interfaces: ::prost::alloc::vec::Vec<NetworkInterfaceUsage>,
    }

    #[doc = " NetworkInterfaceUsage contains resource value data about a network interface."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkInterfaceUsage {
        #[doc = " The name of the network interface."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Cumulative count of bytes received."]
        #[prost(message, optional, tag = "2")] pub rx_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of receive errors encountered."]
        #[prost(message, optional, tag = "3")] pub rx_errors: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of bytes transmitted."]
        #[prost(message, optional, tag = "4")] pub tx_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative count of transmit errors encountered."]
        #[prost(message, optional, tag = "5")] pub tx_errors: ::core::option::Option<UInt64Value>,
    }

    #[doc = " ProcessUsage are stats pertaining to processes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessUsage {
        #[doc = " The time at which these stats were updated."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Number of processes."]
        #[prost(message, optional, tag = "2")] pub process_count: ::core::option::Option<UInt64Value>,
    }

    #[doc = " ImageSpec is an internal representation of an image."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageSpec {
        #[doc = " Container\'s Image field (e.g. imageID or imageDigest)."]
        #[prost(string, tag = "1")] pub image: ::prost::alloc::string::String,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " ImageSpec Annotations can be used to help the runtime target specific"]
        #[doc = " images in multi-arch images."]
        #[prost(map = "string, string", tag = "2")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyValue {
        #[prost(string, tag = "1")] pub key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub value: ::prost::alloc::string::String,
    }

    #[doc = " LinuxContainerResources specifies Linux specific configuration for"]
    #[doc = " resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerResources {
        #[doc = " CPU CFS (Completely Fair Scheduler) period. Default: 0 (not specified)."]
        #[prost(int64, tag = "1")] pub cpu_period: i64,
        #[doc = " CPU CFS (Completely Fair Scheduler) quota. Default: 0 (not specified)."]
        #[prost(int64, tag = "2")] pub cpu_quota: i64,
        #[doc = " CPU shares (relative weight vs. other containers). Default: 0 (not specified)."]
        #[prost(int64, tag = "3")] pub cpu_shares: i64,
        #[doc = " Memory limit in bytes. Default: 0 (not specified)."]
        #[prost(int64, tag = "4")] pub memory_limit_in_bytes: i64,
        #[doc = " OOMScoreAdj adjusts the oom-killer score. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub oom_score_adj: i64,
        #[doc = " CpusetCpus constrains the allowed set of logical CPUs. Default: \"\" (not specified)."]
        #[prost(string, tag = "6")] pub cpuset_cpus: ::prost::alloc::string::String,
        #[doc = " CpusetMems constrains the allowed set of memory nodes. Default: \"\" (not specified)."]
        #[prost(string, tag = "7")] pub cpuset_mems: ::prost::alloc::string::String,
        #[doc = " List of HugepageLimits to limit the HugeTLB usage of container per page size. Default: nil (not specified)."]
        #[prost(message, repeated, tag = "8")] pub hugepage_limits: ::prost::alloc::vec::Vec<HugepageLimit>,
        #[doc = " Unified resources for cgroup v2. Default: nil (not specified)."]
        #[doc = " Each key/value in the map refers to the cgroup v2."]
        #[doc = " e.g. \"memory.max\": \"6937202688\" or \"io.weight\": \"default 100\"."]
        #[prost(map = "string, string", tag = "9")] pub unified: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Memory swap limit in bytes. Default 0 (not specified)."]
        #[prost(int64, tag = "10")] pub memory_swap_limit_in_bytes: i64,
    }

    #[doc = " HugepageLimit corresponds to the file`hugetlb.<hugepagesize>.limit_in_byte` in container level cgroup."]
    #[doc = " For example, `PageSize=1GB`, `Limit=1073741824` means setting `1073741824` bytes to hugetlb.1GB.limit_in_bytes."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HugepageLimit {
        #[doc = " The value of PageSize has the format <size><unit-prefix>B (2MB, 1GB),"]
        #[doc = " and must match the <hugepagesize> of the corresponding control file found in `hugetlb.<hugepagesize>.limit_in_bytes`."]
        #[doc = " The values of <unit-prefix> are intended to be parsed using base 1024(\"1KB\" = 1024, \"1MB\" = 1048576, etc)."]
        #[prost(string, tag = "1")] pub page_size: ::prost::alloc::string::String,
        #[doc = " limit in bytes of hugepagesize HugeTLB usage."]
        #[prost(uint64, tag = "2")] pub limit: u64,
    }

    #[doc = " SELinuxOption are the labels to be applied to the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SeLinuxOption {
        #[prost(string, tag = "1")] pub user: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub role: ::prost::alloc::string::String,
        #[prost(string, tag = "3")] pub r#type: ::prost::alloc::string::String,
        #[prost(string, tag = "4")] pub level: ::prost::alloc::string::String,
    }

    #[doc = " Capability contains the container capabilities to add or drop"]
    #[doc = " Dropping a capability will drop it from all sets."]
    #[doc = " If a capability is added to only the add_capabilities list then it gets added to permitted, "]
    #[doc = " inheritable, effective and bounding sets, i.e. all sets except the ambient set."]
    #[doc = " If a capability is added to only the add_ambient_capabilities list then it gets added to all sets, i.e permitted"]
    #[doc = " inheritable, effective, bounding and ambient sets."]
    #[doc = " If a capability is added to add_capabilities and add_ambient_capabilities lists then it gets added to all sets, i.e."]
    #[doc = " permitted, inheritable, effective, bounding and ambient sets."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Capability {
        #[doc = " List of capabilities to add."]
        #[prost(string, repeated, tag = "1")] pub add_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of capabilities to drop."]
        #[prost(string, repeated, tag = "2")] pub drop_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " List of ambient capabilities to add."]
        #[prost(string, repeated, tag = "3")] pub add_ambient_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }

    #[doc = " LinuxContainerSecurityContext holds linux security configuration that will be applied to a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerSecurityContext {
        #[doc = " Capabilities to add or drop."]
        #[prost(message, optional, tag = "1")] pub capabilities: ::core::option::Option<Capability>,
        #[doc = " If set, run container in privileged mode."]
        #[doc = " Privileged mode is incompatible with the following options. If"]
        #[doc = " privileged is set, the following features MAY have no effect:"]
        #[doc = " 1. capabilities"]
        #[doc = " 2. selinux_options"]
        #[doc = " 4. seccomp"]
        #[doc = " 5. apparmor"]
        #[doc = ""]
        #[doc = " Privileged mode implies the following specific options are applied:"]
        #[doc = " 1. All capabilities are added."]
        #[doc = " 2. Sensitive paths, such as kernel module paths within sysfs, are not masked."]
        #[doc = " 3. Any sysfs and procfs mounts are mounted RW."]
        #[doc = " 4. AppArmor confinement is not applied."]
        #[doc = " 5. Seccomp restrictions are not applied."]
        #[doc = " 6. The device cgroup does not restrict access to any devices."]
        #[doc = " 7. All devices from the host\'s /dev are available within the container."]
        #[doc = " 8. SELinux restrictions are not applied (e.g. label=disabled)."]
        #[prost(bool, tag = "2")] pub privileged: bool,
        #[doc = " Configurations for the container\'s namespaces."]
        #[doc = " Only used if the container uses namespace for isolation."]
        #[prost(message, optional, tag = "3")] pub namespace_options: ::core::option::Option<NamespaceOption>,
        #[doc = " SELinux context to be optionally applied."]
        #[prost(message, optional, tag = "4")] pub selinux_options: ::core::option::Option<SeLinuxOption>,
        #[doc = " UID to run the container process as. Only one of run_as_user and"]
        #[doc = " run_as_username can be specified at a time."]
        #[prost(message, optional, tag = "5")] pub run_as_user: ::core::option::Option<Int64Value>,
        #[doc = " GID to run the container process as. run_as_group should only be specified"]
        #[doc = " when run_as_user or run_as_username is specified; otherwise, the runtime"]
        #[doc = " MUST error."]
        #[prost(message, optional, tag = "12")] pub run_as_group: ::core::option::Option<Int64Value>,
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image (i.e. in the /etc/passwd inside the image),"]
        #[doc = " and be resolved there by the runtime; otherwise, the runtime MUST error."]
        #[prost(string, tag = "6")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " If set, the root filesystem of the container is read-only."]
        #[prost(bool, tag = "7")] pub readonly_rootfs: bool,
        #[doc = " List of groups applied to the first process run in the container, in"]
        #[doc = " addition to the container\'s primary GID."]
        #[prost(int64, repeated, tag = "8")] pub supplemental_groups: ::prost::alloc::vec::Vec<i64>,
        #[doc = " no_new_privs defines if the flag for no_new_privs should be set on the"]
        #[doc = " container."]
        #[prost(bool, tag = "11")] pub no_new_privs: bool,
        #[doc = " masked_paths is a slice of paths that should be masked by the container"]
        #[doc = " runtime, this can be passed directly to the OCI spec."]
        #[prost(string, repeated, tag = "13")] pub masked_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " readonly_paths is a slice of paths that should be set as readonly by the"]
        #[doc = " container runtime, this can be passed directly to the OCI spec."]
        #[prost(string, repeated, tag = "14")] pub readonly_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Seccomp profile for the container."]
        #[prost(message, optional, tag = "15")] pub seccomp: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the container."]
        #[prost(message, optional, tag = "16")] pub apparmor: ::core::option::Option<SecurityProfile>,
        #[doc = " AppArmor profile for the container, candidate values are:"]
        #[doc = " * runtime/default: equivalent to not specifying a profile."]
        #[doc = " * unconfined: no profiles are loaded"]
        #[doc = " * localhost/<profile_name>: profile loaded on the node"]
        #[doc = "     (localhost) by name. The possible profile names are detailed at"]
        #[doc = "     <https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference>"]
        #[deprecated]
        #[prost(string, tag = "9")] pub apparmor_profile: ::prost::alloc::string::String,
        #[doc = " Seccomp profile for the container, candidate values are:"]
        #[doc = " * runtime/default: the default profile for the container runtime"]
        #[doc = " * unconfined: unconfined profile, ie, no seccomp sandboxing"]
        #[doc = " * localhost/<full-path-to-profile>: the profile installed on the node."]
        #[doc = "    <full-path-to-profile> is the full path of the profile."]
        #[doc = " Default: \"\", which is identical with unconfined."]
        #[deprecated]
        #[prost(string, tag = "10")] pub seccomp_profile_path: ::prost::alloc::string::String,
    }

    #[doc = " LinuxContainerConfig contains platform-specific configuration for"]
    #[doc = " Linux-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinuxContainerConfig {
        #[doc = " Resources specification for the container."]
        #[prost(message, optional, tag = "1")] pub resources: ::core::option::Option<LinuxContainerResources>,
        #[doc = " LinuxContainerSecurityContext configuration for the container."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<LinuxContainerSecurityContext>,
    }

    #[doc = " WindowsSandboxSecurityContext holds platform-specific configurations that will be"]
    #[doc = " applied to a sandbox."]
    #[doc = " These settings will only apply to the sandbox container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsSandboxSecurityContext {
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image and be resolved there by the runtime;"]
        #[doc = " otherwise, the runtime MUST return error."]
        #[prost(string, tag = "1")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " The contents of the GMSA credential spec to use to run this container."]
        #[prost(string, tag = "2")] pub credential_spec: ::prost::alloc::string::String,
        #[doc = " Indicates whether the container requested to run as a HostProcess container."]
        #[prost(bool, tag = "3")] pub host_process: bool,
    }

    #[doc = " WindowsPodSandboxConfig holds platform-specific configurations for Windows"]
    #[doc = " host platforms and Windows-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsPodSandboxConfig {
        #[doc = " WindowsSandboxSecurityContext holds sandbox security attributes."]
        #[prost(message, optional, tag = "1")] pub security_context: ::core::option::Option<WindowsSandboxSecurityContext>,
    }

    #[doc = " WindowsContainerSecurityContext holds windows security configuration that will be applied to a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerSecurityContext {
        #[doc = " User name to run the container process as. If specified, the user MUST"]
        #[doc = " exist in the container image and be resolved there by the runtime;"]
        #[doc = " otherwise, the runtime MUST return error."]
        #[prost(string, tag = "1")] pub run_as_username: ::prost::alloc::string::String,
        #[doc = " The contents of the GMSA credential spec to use to run this container."]
        #[prost(string, tag = "2")] pub credential_spec: ::prost::alloc::string::String,
        #[doc = " Indicates whether a container is to be run as a HostProcess container."]
        #[prost(bool, tag = "3")] pub host_process: bool,
    }

    #[doc = " WindowsContainerConfig contains platform-specific configuration for"]
    #[doc = " Windows-based containers."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerConfig {
        #[doc = " Resources specification for the container."]
        #[prost(message, optional, tag = "1")] pub resources: ::core::option::Option<WindowsContainerResources>,
        #[doc = " WindowsContainerSecurityContext configuration for the container."]
        #[prost(message, optional, tag = "2")] pub security_context: ::core::option::Option<WindowsContainerSecurityContext>,
    }

    #[doc = " WindowsContainerResources specifies Windows specific configuration for"]
    #[doc = " resources."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WindowsContainerResources {
        #[doc = " CPU shares (relative weight vs. other containers). Default: 0 (not specified)."]
        #[prost(int64, tag = "1")] pub cpu_shares: i64,
        #[doc = " Number of CPUs available to the container. Default: 0 (not specified)."]
        #[prost(int64, tag = "2")] pub cpu_count: i64,
        #[doc = " Specifies the portion of processor cycles that this container can use as a percentage times 100."]
        #[prost(int64, tag = "3")] pub cpu_maximum: i64,
        #[doc = " Memory limit in bytes. Default: 0 (not specified)."]
        #[prost(int64, tag = "4")] pub memory_limit_in_bytes: i64,
        #[doc = " Specifies the size of the rootfs / scratch space in bytes to be configured for this container. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub rootfs_size_in_bytes: i64,
    }

    #[doc = " ContainerMetadata holds all necessary information for building the container"]
    #[doc = " name. The container runtime is encouraged to expose the metadata in its user"]
    #[doc = " interface for better user experience. E.g., runtime can construct a unique"]
    #[doc = " container name based on the metadata. Note that (name, attempt) is unique"]
    #[doc = " within a sandbox for the entire lifetime of the sandbox."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerMetadata {
        #[doc = " Name of the container. Same as the container name in the PodSpec."]
        #[prost(string, tag = "1")] pub name: ::prost::alloc::string::String,
        #[doc = " Attempt number of creating the container. Default: 0."]
        #[prost(uint32, tag = "2")] pub attempt: u32,
    }

    #[doc = " Device specifies a host device to mount into a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        #[doc = " Path of the device within the container."]
        #[prost(string, tag = "1")] pub container_path: ::prost::alloc::string::String,
        #[doc = " Path of the device on the host."]
        #[prost(string, tag = "2")] pub host_path: ::prost::alloc::string::String,
        #[doc = " Cgroups permissions of the device, candidates are one or more of"]
        #[doc = " * r - allows container to read from the specified device."]
        #[doc = " * w - allows container to write to the specified device."]
        #[doc = " * m - allows container to create device files that do not yet exist."]
        #[prost(string, tag = "3")] pub permissions: ::prost::alloc::string::String,
    }

    #[doc = " ContainerConfig holds all the required and optional fields for creating a"]
    #[doc = " container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerConfig {
        #[doc = " Metadata of the container. This information will uniquely identify the"]
        #[doc = " container, and the runtime should leverage this to ensure correct"]
        #[doc = " operation. The runtime may also use this information to improve UX, such"]
        #[doc = " as by constructing a readable name."]
        #[prost(message, optional, tag = "1")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Image to use."]
        #[prost(message, optional, tag = "2")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Command to execute (i.e., entrypoint for docker)"]
        #[prost(string, repeated, tag = "3")] pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Args for the Command (i.e., command for docker)"]
        #[prost(string, repeated, tag = "4")] pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Current working directory of the command."]
        #[prost(string, tag = "5")] pub working_dir: ::prost::alloc::string::String,
        #[doc = " List of environment variable to set in the container."]
        #[prost(message, repeated, tag = "6")] pub envs: ::prost::alloc::vec::Vec<KeyValue>,
        #[doc = " Mounts for the container."]
        #[prost(message, repeated, tag = "7")] pub mounts: ::prost::alloc::vec::Vec<Mount>,
        #[doc = " Devices for the container."]
        #[prost(message, repeated, tag = "8")] pub devices: ::prost::alloc::vec::Vec<Device>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[doc = " Label keys are of the form:"]
        #[doc = "      label-key ::= prefixed-name | name"]
        #[doc = "      prefixed-name ::= prefix \'/\' name"]
        #[doc = "      prefix ::= DNS_SUBDOMAIN"]
        #[doc = "      name ::= DNS_LABEL"]
        #[prost(map = "string, string", tag = "9")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map that may be used by the kubelet to store and"]
        #[doc = " retrieve arbitrary metadata."]
        #[doc = ""]
        #[doc = " Annotations MUST NOT be altered by the runtime; the annotations stored"]
        #[doc = " here MUST be returned in the ContainerStatus associated with the container"]
        #[doc = " this ContainerConfig creates."]
        #[doc = ""]
        #[doc = " In general, in order to preserve a well-defined interface between the"]
        #[doc = " kubelet and the container runtime, annotations SHOULD NOT influence"]
        #[doc = " runtime behaviour."]
        #[prost(map = "string, string", tag = "10")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Path relative to PodSandboxConfig.LogDirectory for container to store"]
        #[doc = " the log (STDOUT and STDERR) on the host."]
        #[doc = " E.g.,"]
        #[doc = "      PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`"]
        #[doc = "      ContainerConfig.LogPath = `containerName/Instance#.log`"]
        #[doc = ""]
        #[doc = " WARNING: Log management and how kubelet should interface with the"]
        #[doc = " container logs are under active discussion in"]
        #[doc = " <https://issues.k8s.io/24677.> There *may* be future change of direction"]
        #[doc = " for logging as the discussion carries on."]
        #[prost(string, tag = "11")] pub log_path: ::prost::alloc::string::String,
        #[doc = " Variables for interactive containers, these have very specialized"]
        #[doc = " use-cases (e.g. debugging)."]
        #[prost(bool, tag = "12")] pub stdin: bool,
        #[prost(bool, tag = "13")] pub stdin_once: bool,
        #[prost(bool, tag = "14")] pub tty: bool,
        #[doc = " Configuration specific to Linux containers."]
        #[prost(message, optional, tag = "15")] pub linux: ::core::option::Option<LinuxContainerConfig>,
        #[doc = " Configuration specific to Windows containers."]
        #[prost(message, optional, tag = "16")] pub windows: ::core::option::Option<WindowsContainerConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateContainerRequest {
        #[doc = " ID of the PodSandbox in which the container should be created."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Config of the container."]
        #[prost(message, optional, tag = "2")] pub config: ::core::option::Option<ContainerConfig>,
        #[doc = " Config of the PodSandbox. This is the same config that was passed"]
        #[doc = " to RunPodSandboxRequest to create the PodSandbox. It is passed again"]
        #[doc = " here just for easy reference. The PodSandboxConfig is immutable and"]
        #[doc = " remains the same throughout the lifetime of the pod."]
        #[prost(message, optional, tag = "3")] pub sandbox_config: ::core::option::Option<PodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateContainerResponse {
        #[doc = " ID of the created container."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartContainerRequest {
        #[doc = " ID of the container to start."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartContainerResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopContainerRequest {
        #[doc = " ID of the container to stop."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Timeout in seconds to wait for the container to stop before forcibly"]
        #[doc = " terminating it. Default: 0 (forcibly terminate the container immediately)"]
        #[prost(int64, tag = "2")] pub timeout: i64,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopContainerResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveContainerRequest {
        #[doc = " ID of the container to remove."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveContainerResponse {}

    #[doc = " ContainerStateValue is the wrapper of ContainerState."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStateValue {
        #[doc = " State of the container."]
        #[prost(enumeration = "ContainerState", tag = "1")] pub state: i32,
    }

    #[doc = " ContainerFilter is used to filter containers."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerFilter {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " State of the container."]
        #[prost(message, optional, tag = "2")] pub state: ::core::option::Option<ContainerStateValue>,
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "3")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "4")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainersRequest {
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ContainerFilter>,
    }

    #[doc = " Container provides the runtime information for a container, such as ID, hash,"]
    #[doc = " state of the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Container {
        #[doc = " ID of the container, used by the container runtime to identify"]
        #[doc = " a container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " ID of the sandbox to which this container belongs."]
        #[prost(string, tag = "2")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "3")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "4")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID."]
        #[prost(string, tag = "5")] pub image_ref: ::prost::alloc::string::String,
        #[doc = " State of the container."]
        #[prost(enumeration = "ContainerState", tag = "6")] pub state: i32,
        #[doc = " Creation time of the container in nanoseconds."]
        #[prost(int64, tag = "7")] pub created_at: i64,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "8")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate this Container."]
        #[prost(map = "string, string", tag = "9")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainersResponse {
        #[doc = " List of containers."]
        #[prost(message, repeated, tag = "1")] pub containers: ::prost::alloc::vec::Vec<Container>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatusRequest {
        #[doc = " ID of the container for which to retrieve status."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Verbose indicates whether to return extra information about the container."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[doc = " ContainerStatus represents the status of a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatus {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Status of the container."]
        #[prost(enumeration = "ContainerState", tag = "3")] pub state: i32,
        #[doc = " Creation time of the container in nanoseconds."]
        #[prost(int64, tag = "4")] pub created_at: i64,
        #[doc = " Start time of the container in nanoseconds. Default: 0 (not specified)."]
        #[prost(int64, tag = "5")] pub started_at: i64,
        #[doc = " Finish time of the container in nanoseconds. Default: 0 (not specified)."]
        #[prost(int64, tag = "6")] pub finished_at: i64,
        #[doc = " Exit code of the container. Only required when finished_at != 0. Default: 0."]
        #[prost(int32, tag = "7")] pub exit_code: i32,
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "8")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID"]
        #[prost(string, tag = "9")] pub image_ref: ::prost::alloc::string::String,
        #[doc = " Brief CamelCase string explaining why container is in its current state."]
        #[prost(string, tag = "10")] pub reason: ::prost::alloc::string::String,
        #[doc = " Human-readable message indicating details about why container is in its"]
        #[doc = " current state."]
        #[prost(string, tag = "11")] pub message: ::prost::alloc::string::String,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "12")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate the Container this status represents."]
        #[prost(map = "string, string", tag = "13")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Mounts for the container."]
        #[prost(message, repeated, tag = "14")] pub mounts: ::prost::alloc::vec::Vec<Mount>,
        #[doc = " Log path of container."]
        #[prost(string, tag = "15")] pub log_path: ::prost::alloc::string::String,
        #[doc = " Resource limits configuration of the container."]
        #[prost(message, optional, tag = "16")] pub resources: ::core::option::Option<ContainerResources>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatusResponse {
        #[doc = " Status of the container."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<ContainerStatus>,
        #[doc = " Info is extra information of the Container. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. pid for linux container based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " ContainerResources holds resource limits configuration for a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerResources {
        #[doc = " Resource limits configuration specific to Linux container."]
        #[prost(message, optional, tag = "1")] pub linux: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Resource limits configuration specific to Windows container."]
        #[prost(message, optional, tag = "2")] pub windows: ::core::option::Option<WindowsContainerResources>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateContainerResourcesRequest {
        #[doc = " ID of the container to update."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Resource configuration specific to Linux containers."]
        #[prost(message, optional, tag = "2")] pub linux: ::core::option::Option<LinuxContainerResources>,
        #[doc = " Resource configuration specific to Windows containers."]
        #[prost(message, optional, tag = "3")] pub windows: ::core::option::Option<WindowsContainerResources>,
        #[doc = " Unstructured key-value map holding arbitrary additional information for"]
        #[doc = " container resources updating. This can be used for specifying experimental"]
        #[doc = " resources to update or other options to use when updating the container."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateContainerResourcesResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecSyncRequest {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Command to execute."]
        #[prost(string, repeated, tag = "2")] pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Timeout in seconds to stop the command. Default: 0 (run forever)."]
        #[prost(int64, tag = "3")] pub timeout: i64,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecSyncResponse {
        #[doc = " Captured command stdout output."]
        #[prost(bytes = "vec", tag = "1")] pub stdout: ::prost::alloc::vec::Vec<u8>,
        #[doc = " Captured command stderr output."]
        #[prost(bytes = "vec", tag = "2")] pub stderr: ::prost::alloc::vec::Vec<u8>,
        #[doc = " Exit code the command finished with. Default: 0 (success)."]
        #[prost(int32, tag = "3")] pub exit_code: i32,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecRequest {
        #[doc = " ID of the container in which to execute the command."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Command to execute."]
        #[prost(string, repeated, tag = "2")] pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Whether to exec the command in a TTY."]
        #[prost(bool, tag = "3")] pub tty: bool,
        #[doc = " Whether to stream stdin."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "4")] pub stdin: bool,
        #[doc = " Whether to stream stdout."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "5")] pub stdout: bool,
        #[doc = " Whether to stream stderr."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[doc = " If `tty` is true, `stderr` MUST be false. Multiplexing is not supported"]
        #[doc = " in this case. The output of stdout and stderr will be combined to a"]
        #[doc = " single stream."]
        #[prost(bool, tag = "6")] pub stderr: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecResponse {
        #[doc = " Fully qualified URL of the exec streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachRequest {
        #[doc = " ID of the container to which to attach."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
        #[doc = " Whether to stream stdin."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "2")] pub stdin: bool,
        #[doc = " Whether the process being attached is running in a TTY."]
        #[doc = " This must match the TTY setting in the ContainerConfig."]
        #[prost(bool, tag = "3")] pub tty: bool,
        #[doc = " Whether to stream stdout."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[prost(bool, tag = "4")] pub stdout: bool,
        #[doc = " Whether to stream stderr."]
        #[doc = " One of `stdin`, `stdout`, and `stderr` MUST be true."]
        #[doc = " If `tty` is true, `stderr` MUST be false. Multiplexing is not supported"]
        #[doc = " in this case. The output of stdout and stderr will be combined to a"]
        #[doc = " single stream."]
        #[prost(bool, tag = "5")] pub stderr: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachResponse {
        #[doc = " Fully qualified URL of the attach streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortForwardRequest {
        #[doc = " ID of the container to which to forward the port."]
        #[prost(string, tag = "1")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " Port to forward."]
        #[prost(int32, repeated, tag = "2")] pub port: ::prost::alloc::vec::Vec<i32>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PortForwardResponse {
        #[doc = " Fully qualified URL of the port-forward streaming server."]
        #[prost(string, tag = "1")] pub url: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFilter {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListImagesRequest {
        #[doc = " Filter to list images."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ImageFilter>,
    }

    #[doc = " Basic information about a container image."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Image {
        #[doc = " ID of the image."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Other names by which this image is known."]
        #[prost(string, repeated, tag = "2")] pub repo_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Digests by which this image is known."]
        #[prost(string, repeated, tag = "3")] pub repo_digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[doc = " Size of the image in bytes. Must be > 0."]
        #[prost(uint64, tag = "4")] pub size: u64,
        #[doc = " UID that will run the command(s). This is used as a default if no user is"]
        #[doc = " specified when creating the container. UID and the following user name"]
        #[doc = " are mutually exclusive."]
        #[prost(message, optional, tag = "5")] pub uid: ::core::option::Option<Int64Value>,
        #[doc = " User name that will run the command(s). This is used if UID is not set"]
        #[doc = " and no user is specified when creating container."]
        #[prost(string, tag = "6")] pub username: ::prost::alloc::string::String,
        #[doc = " ImageSpec for image which includes annotations"]
        #[prost(message, optional, tag = "7")] pub spec: ::core::option::Option<ImageSpec>,
        #[doc = " Recommendation on whether this image should be exempt from garbage collection."]
        #[doc = " It must only be treated as a recommendation -- the client can still request that the image be deleted,"]
        #[doc = " and the runtime must oblige."]
        #[prost(bool, tag = "8")] pub pinned: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListImagesResponse {
        #[doc = " List of images."]
        #[prost(message, repeated, tag = "1")] pub images: ::prost::alloc::vec::Vec<Image>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageStatusRequest {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Verbose indicates whether to return extra information about the image."]
        #[prost(bool, tag = "2")] pub verbose: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageStatusResponse {
        #[doc = " Status of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<Image>,
        #[doc = " Info is extra information of the Image. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful"]
        #[doc = " for debug, e.g. image config for oci image based container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " AuthConfig contains authorization information for connecting to a registry."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthConfig {
        #[prost(string, tag = "1")] pub username: ::prost::alloc::string::String,
        #[prost(string, tag = "2")] pub password: ::prost::alloc::string::String,
        #[prost(string, tag = "3")] pub auth: ::prost::alloc::string::String,
        #[prost(string, tag = "4")] pub server_address: ::prost::alloc::string::String,
        #[doc = " IdentityToken is used to authenticate the user and get"]
        #[doc = " an access token for the registry."]
        #[prost(string, tag = "5")] pub identity_token: ::prost::alloc::string::String,
        #[doc = " RegistryToken is a bearer token to be sent to a registry"]
        #[prost(string, tag = "6")] pub registry_token: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PullImageRequest {
        #[doc = " Spec of the image."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
        #[doc = " Authentication configuration for pulling the image."]
        #[prost(message, optional, tag = "2")] pub auth: ::core::option::Option<AuthConfig>,
        #[doc = " Config of the PodSandbox, which is used to pull image in PodSandbox context."]
        #[prost(message, optional, tag = "3")] pub sandbox_config: ::core::option::Option<PodSandboxConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PullImageResponse {
        #[doc = " Reference to the image in use. For most runtimes, this should be an"]
        #[doc = " image ID or digest."]
        #[prost(string, tag = "1")] pub image_ref: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveImageRequest {
        #[doc = " Spec of the image to remove."]
        #[prost(message, optional, tag = "1")] pub image: ::core::option::Option<ImageSpec>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveImageResponse {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkConfig {
        #[doc = " CIDR to use for pod IP addresses. If the CIDR is empty, runtimes"]
        #[doc = " should omit it."]
        #[prost(string, tag = "1")] pub pod_cidr: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeConfig {
        #[prost(message, optional, tag = "1")] pub network_config: ::core::option::Option<NetworkConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateRuntimeConfigRequest {
        #[prost(message, optional, tag = "1")] pub runtime_config: ::core::option::Option<RuntimeConfig>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateRuntimeConfigResponse {}

    #[doc = " RuntimeCondition contains condition information for the runtime."]
    #[doc = " There are 2 kinds of runtime conditions:"]
    #[doc = " 1. Required conditions: Conditions are required for kubelet to work"]
    #[doc = " properly. If any required condition is unmet, the node will be not ready."]
    #[doc = " The required conditions include:"]
    #[doc = "    * RuntimeReady: RuntimeReady means the runtime is up and ready to accept"]
    #[doc = "    basic containers e.g. container only needs host network."]
    #[doc = "    * NetworkReady: NetworkReady means the runtime network is up and ready to"]
    #[doc = "    accept containers which require container network."]
    #[doc = " 2. Optional conditions: Conditions are informative to the user, but kubelet"]
    #[doc = " will not rely on. Since condition type is an arbitrary string, all conditions"]
    #[doc = " not required are optional. These conditions will be exposed to users to help"]
    #[doc = " them understand the status of the system."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeCondition {
        #[doc = " Type of runtime condition."]
        #[prost(string, tag = "1")] pub r#type: ::prost::alloc::string::String,
        #[doc = " Status of the condition, one of true/false. Default: false."]
        #[prost(bool, tag = "2")] pub status: bool,
        #[doc = " Brief CamelCase string containing reason for the condition\'s last transition."]
        #[prost(string, tag = "3")] pub reason: ::prost::alloc::string::String,
        #[doc = " Human-readable message indicating details about last transition."]
        #[prost(string, tag = "4")] pub message: ::prost::alloc::string::String,
    }

    #[doc = " RuntimeStatus is information about the current status of the runtime."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeStatus {
        #[doc = " List of current observed runtime conditions."]
        #[prost(message, repeated, tag = "1")] pub conditions: ::prost::alloc::vec::Vec<RuntimeCondition>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatusRequest {
        #[doc = " Verbose indicates whether to return extra information about the runtime."]
        #[prost(bool, tag = "1")] pub verbose: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatusResponse {
        #[doc = " Status of the Runtime."]
        #[prost(message, optional, tag = "1")] pub status: ::core::option::Option<RuntimeStatus>,
        #[doc = " Info is extra information of the Runtime. The key could be arbitrary string, and"]
        #[doc = " value should be in json format. The information could include anything useful for"]
        #[doc = " debug, e.g. plugins used by the container runtime."]
        #[doc = " It should only be returned non-empty when Verbose is true."]
        #[prost(map = "string, string", tag = "2")] pub info: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFsInfoRequest {}

    #[doc = " UInt64Value is the wrapper of uint64."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UInt64Value {
        #[doc = " The value."]
        #[prost(uint64, tag = "1")] pub value: u64,
    }

    #[doc = " FilesystemIdentifier uniquely identify the filesystem."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilesystemIdentifier {
        #[doc = " Mountpoint of a filesystem."]
        #[prost(string, tag = "1")] pub mountpoint: ::prost::alloc::string::String,
    }

    #[doc = " FilesystemUsage provides the filesystem usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilesystemUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " The unique identifier of the filesystem."]
        #[prost(message, optional, tag = "2")] pub fs_id: ::core::option::Option<FilesystemIdentifier>,
        #[doc = " UsedBytes represents the bytes used for images on the filesystem."]
        #[doc = " This may differ from the total bytes used on the filesystem and may not"]
        #[doc = " equal CapacityBytes - AvailableBytes."]
        #[prost(message, optional, tag = "3")] pub used_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " InodesUsed represents the inodes used by the images."]
        #[doc = " This may not equal InodesCapacity - InodesAvailable because the underlying"]
        #[doc = " filesystem may also be used for purposes other than storing images."]
        #[prost(message, optional, tag = "4")] pub inodes_used: ::core::option::Option<UInt64Value>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageFsInfoResponse {
        #[doc = " Information of image filesystem(s)."]
        #[prost(message, repeated, tag = "1")] pub image_filesystems: ::prost::alloc::vec::Vec<FilesystemUsage>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsRequest {
        #[doc = " ID of the container for which to retrieve stats."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsResponse {
        #[doc = " Stats of the container."]
        #[prost(message, optional, tag = "1")] pub stats: ::core::option::Option<ContainerStats>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainerStatsRequest {
        #[doc = " Filter for the list request."]
        #[prost(message, optional, tag = "1")] pub filter: ::core::option::Option<ContainerStatsFilter>,
    }

    #[doc = " ContainerStatsFilter is used to filter containers."]
    #[doc = " All those fields are combined with \'AND\'"]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStatsFilter {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " ID of the PodSandbox."]
        #[prost(string, tag = "2")] pub pod_sandbox_id: ::prost::alloc::string::String,
        #[doc = " LabelSelector to select matches."]
        #[doc = " Only api.MatchLabels is supported for now and the requirements"]
        #[doc = " are ANDed. MatchExpressions is not supported yet."]
        #[prost(map = "string, string", tag = "3")] pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListContainerStatsResponse {
        #[doc = " Stats of the container."]
        #[prost(message, repeated, tag = "1")] pub stats: ::prost::alloc::vec::Vec<ContainerStats>,
    }

    #[doc = " ContainerAttributes provides basic information of the container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerAttributes {
        #[doc = " ID of the container."]
        #[prost(string, tag = "1")] pub id: ::prost::alloc::string::String,
        #[doc = " Metadata of the container."]
        #[prost(message, optional, tag = "2")] pub metadata: ::core::option::Option<ContainerMetadata>,
        #[doc = " Key-value pairs that may be used to scope and select individual resources."]
        #[prost(map = "string, string", tag = "3")] pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
        #[doc = " Unstructured key-value map holding arbitrary metadata."]
        #[doc = " Annotations MUST NOT be altered by the runtime; the value of this field"]
        #[doc = " MUST be identical to that of the corresponding ContainerConfig used to"]
        #[doc = " instantiate the Container this status represents."]
        #[prost(map = "string, string", tag = "4")] pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }

    #[doc = " ContainerStats provides the resource usage statistics for a container."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerStats {
        #[doc = " Information of the container."]
        #[prost(message, optional, tag = "1")] pub attributes: ::core::option::Option<ContainerAttributes>,
        #[doc = " CPU usage gathered from the container."]
        #[prost(message, optional, tag = "2")] pub cpu: ::core::option::Option<CpuUsage>,
        #[doc = " Memory usage gathered from the container."]
        #[prost(message, optional, tag = "3")] pub memory: ::core::option::Option<MemoryUsage>,
        #[doc = " Usage of the writable layer."]
        #[prost(message, optional, tag = "4")] pub writable_layer: ::core::option::Option<FilesystemUsage>,
    }

    #[doc = " CpuUsage provides the CPU usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CpuUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " Cumulative CPU usage (sum across all cores) since object creation."]
        #[prost(message, optional, tag = "2")] pub usage_core_nano_seconds: ::core::option::Option<UInt64Value>,
        #[doc = " Total CPU usage (sum of all cores) averaged over the sample window."]
        #[doc = " The \"core\" unit can be interpreted as CPU core-nanoseconds per second."]
        #[prost(message, optional, tag = "3")] pub usage_nano_cores: ::core::option::Option<UInt64Value>,
    }

    #[doc = " MemoryUsage provides the memory usage information."]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MemoryUsage {
        #[doc = " Timestamp in nanoseconds at which the information were collected. Must be > 0."]
        #[prost(int64, tag = "1")] pub timestamp: i64,
        #[doc = " The amount of working set memory in bytes."]
        #[prost(message, optional, tag = "2")] pub working_set_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Available memory for use. This is defined as the memory limit - workingSetBytes."]
        #[prost(message, optional, tag = "3")] pub available_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Total memory in use. This includes all memory regardless of when it was accessed."]
        #[prost(message, optional, tag = "4")] pub usage_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " The amount of anonymous and swap cache memory (includes transparent hugepages)."]
        #[prost(message, optional, tag = "5")] pub rss_bytes: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative number of minor page faults."]
        #[prost(message, optional, tag = "6")] pub page_faults: ::core::option::Option<UInt64Value>,
        #[doc = " Cumulative number of major page faults."]
        #[prost(message, optional, tag = "7")] pub major_page_faults: ::core::option::Option<UInt64Value>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReopenContainerLogRequest {
        #[doc = " ID of the container for which to reopen the log."]
        #[prost(string, tag = "1")] pub container_id: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReopenContainerLogResponse {}

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Protocol { Tcp = 0, Udp = 1, Sctp = 2 }

    impl Protocol {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Protocol::Tcp => "TCP",
                Protocol::Udp => "UDP",
                Protocol::Sctp => "SCTP",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MountPropagation {
        #[doc = " No mount propagation (\"private\" in Linux terminology)."] PropagationPrivate = 0,
        #[doc = " Mounts get propagated from the host to the container (\"rslave\" in Linux)."] PropagationHostToContainer = 1,
        #[doc = " Mounts get propagated from the host to the container and from the"]
        #[doc = " container to the host (\"rshared\" in Linux)."] PropagationBidirectional = 2,
    }

    impl MountPropagation {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MountPropagation::PropagationPrivate => "PROPAGATION_PRIVATE",
                MountPropagation::PropagationHostToContainer => "PROPAGATION_HOST_TO_CONTAINER",
                MountPropagation::PropagationBidirectional => "PROPAGATION_BIDIRECTIONAL",
            }
        }
    }

    #[doc = " A NamespaceMode describes the intended namespace configuration for each"]
    #[doc = " of the namespaces (Network, PID, IPC) in NamespaceOption. Runtimes should"]
    #[doc = " map these modes as appropriate for the technology underlying the runtime."]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum NamespaceMode {
        #[doc = " A POD namespace is common to all containers in a pod."]
        #[doc = " For example, a container with a PID namespace of POD expects to view"]
        #[doc = " all of the processes in all of the containers in the pod."] Pod = 0,
        #[doc = " A CONTAINER namespace is restricted to a single container."]
        #[doc = " For example, a container with a PID namespace of CONTAINER expects to"]
        #[doc = " view only the processes in that container."] Container = 1,
        #[doc = " A NODE namespace is the namespace of the Kubernetes node."]
        #[doc = " For example, a container with a PID namespace of NODE expects to view"]
        #[doc = " all of the processes on the host running the kubelet."] Node = 2,
        #[doc = " TARGET targets the namespace of another container. When this is specified,"]
        #[doc = " a target_id must be specified in NamespaceOption and refer to a container"]
        #[doc = " previously created with NamespaceMode CONTAINER. This containers namespace"]
        #[doc = " will be made to match that of container target_id."]
        #[doc = " For example, a container with a PID namespace of TARGET expects to view"]
        #[doc = " all of the processes that container target_id can view."] Target = 3,
    }

    impl NamespaceMode {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NamespaceMode::Pod => "POD",
                NamespaceMode::Container => "CONTAINER",
                NamespaceMode::Node => "NODE",
                NamespaceMode::Target => "TARGET",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PodSandboxState { SandboxReady = 0, SandboxNotready = 1 }

    impl PodSandboxState {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PodSandboxState::SandboxReady => "SANDBOX_READY",
                PodSandboxState::SandboxNotready => "SANDBOX_NOTREADY",
            }
        }
    }

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ContainerState { ContainerCreated = 0, ContainerRunning = 1, ContainerExited = 2, ContainerUnknown = 3 }

    impl ContainerState {
        #[doc = " String value of the enum field names used in the ProtoBuf definition."]
        #[doc = ""]
        #[doc = " The values are not transformed in any way and thus are considered stable"]
        #[doc = " (if the ProtoBuf definition does not change) and safe for programmatic use."]
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContainerState::ContainerCreated => "CONTAINER_CREATED",
                ContainerState::ContainerRunning => "CONTAINER_RUNNING",
                ContainerState::ContainerExited => "CONTAINER_EXITED",
                ContainerState::ContainerUnknown => "CONTAINER_UNKNOWN",
            }
        }
    }

    #[doc = " Generated server implementations."]
    mod runtime_service_server {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]

        use tonic::codegen::*;

        #[doc = "Generated trait containing gRPC methods that should be implemented for use with RuntimeServiceServer."]
        #[async_trait]
        pub trait RuntimeService: Send + Sync + 'static {
            #[doc = " Version returns the runtime name, runtime version, and runtime API version."]
            async fn version(&self, request: tonic::Request<super::VersionRequest>) -> Result<tonic::Response<super::VersionResponse>, tonic::Status>;
            #[doc = " RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure"]
            #[doc = " the sandbox is in the ready state on success."]
            async fn run_pod_sandbox(&self, request: tonic::Request<super::RunPodSandboxRequest>) -> Result<tonic::Response<super::RunPodSandboxResponse>, tonic::Status>;
            #[doc = " StopPodSandbox stops any running process that is part of the sandbox and"]
            #[doc = " reclaims network resources (e.g., IP addresses) allocated to the sandbox."]
            #[doc = " If there are any running containers in the sandbox, they must be forcibly"]
            #[doc = " terminated."]
            #[doc = " This call is idempotent, and must not return an error if all relevant"]
            #[doc = " resources have already been reclaimed. kubelet will call StopPodSandbox"]
            #[doc = " at least once before calling RemovePodSandbox. It will also attempt to"]
            #[doc = " reclaim resources eagerly, as soon as a sandbox is not needed. Hence,"]
            #[doc = " multiple StopPodSandbox calls are expected."]
            async fn stop_pod_sandbox(&self, request: tonic::Request<super::StopPodSandboxRequest>) -> Result<tonic::Response<super::StopPodSandboxResponse>, tonic::Status>;
            #[doc = " RemovePodSandbox removes the sandbox. If there are any running containers"]
            #[doc = " in the sandbox, they must be forcibly terminated and removed."]
            #[doc = " This call is idempotent, and must not return an error if the sandbox has"]
            #[doc = " already been removed."]
            async fn remove_pod_sandbox(&self, request: tonic::Request<super::RemovePodSandboxRequest>) -> Result<tonic::Response<super::RemovePodSandboxResponse>, tonic::Status>;
            #[doc = " PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not"]
            #[doc = " present, returns an error."]
            async fn pod_sandbox_status(&self, request: tonic::Request<super::PodSandboxStatusRequest>) -> Result<tonic::Response<super::PodSandboxStatusResponse>, tonic::Status>;
            #[doc = " ListPodSandbox returns a list of PodSandboxes."]
            async fn list_pod_sandbox(&self, request: tonic::Request<super::ListPodSandboxRequest>) -> Result<tonic::Response<super::ListPodSandboxResponse>, tonic::Status>;
            #[doc = " CreateContainer creates a new container in specified PodSandbox"]
            async fn create_container(&self, request: tonic::Request<super::CreateContainerRequest>) -> Result<tonic::Response<super::CreateContainerResponse>, tonic::Status>;
            #[doc = " StartContainer starts the container."]
            async fn start_container(&self, request: tonic::Request<super::StartContainerRequest>) -> Result<tonic::Response<super::StartContainerResponse>, tonic::Status>;
            #[doc = " StopContainer stops a running container with a grace period (i.e., timeout)."]
            #[doc = " This call is idempotent, and must not return an error if the container has"]
            #[doc = " already been stopped."]
            #[doc = " The runtime must forcibly kill the container after the grace period is"]
            #[doc = " reached."]
            async fn stop_container(&self, request: tonic::Request<super::StopContainerRequest>) -> Result<tonic::Response<super::StopContainerResponse>, tonic::Status>;
            #[doc = " RemoveContainer removes the container. If the container is running, the"]
            #[doc = " container must be forcibly removed."]
            #[doc = " This call is idempotent, and must not return an error if the container has"]
            #[doc = " already been removed."]
            async fn remove_container(&self, request: tonic::Request<super::RemoveContainerRequest>) -> Result<tonic::Response<super::RemoveContainerResponse>, tonic::Status>;
            #[doc = " ListContainers lists all containers by filters."]
            async fn list_containers(&self, request: tonic::Request<super::ListContainersRequest>) -> Result<tonic::Response<super::ListContainersResponse>, tonic::Status>;
            #[doc = " ContainerStatus returns status of the container. If the container is not"]
            #[doc = " present, returns an error."]
            async fn container_status(&self, request: tonic::Request<super::ContainerStatusRequest>) -> Result<tonic::Response<super::ContainerStatusResponse>, tonic::Status>;
            #[doc = " UpdateContainerResources updates ContainerConfig of the container synchronously."]
            #[doc = " If runtime fails to transactionally update the requested resources, an error is returned."]
            async fn update_container_resources(&self, request: tonic::Request<super::UpdateContainerResourcesRequest>) -> Result<tonic::Response<super::UpdateContainerResourcesResponse>, tonic::Status, >;
            #[doc = " ReopenContainerLog asks runtime to reopen the stdout/stderr log file"]
            #[doc = " for the container. This is often called after the log file has been"]
            #[doc = " rotated. If the container is not running, container runtime can choose"]
            #[doc = " to either create a new log file and return nil, or return an error."]
            #[doc = " Once it returns error, new container log file MUST NOT be created."]
            async fn reopen_container_log(&self, request: tonic::Request<super::ReopenContainerLogRequest>) -> Result<tonic::Response<super::ReopenContainerLogResponse>, tonic::Status>;
            #[doc = " ExecSync runs a command in a container synchronously."]
            async fn exec_sync(&self, request: tonic::Request<super::ExecSyncRequest>) -> Result<tonic::Response<super::ExecSyncResponse>, tonic::Status>;
            #[doc = " Exec prepares a streaming endpoint to execute a command in the container."]
            async fn exec(&self, request: tonic::Request<super::ExecRequest>) -> Result<tonic::Response<super::ExecResponse>, tonic::Status>;
            #[doc = " Attach prepares a streaming endpoint to attach to a running container."]
            async fn attach(&self, request: tonic::Request<super::AttachRequest>) -> Result<tonic::Response<super::AttachResponse>, tonic::Status>;
            #[doc = " PortForward prepares a streaming endpoint to forward ports from a PodSandbox."]
            async fn port_forward(&self, request: tonic::Request<super::PortForwardRequest>) -> Result<tonic::Response<super::PortForwardResponse>, tonic::Status>;
            #[doc = " ContainerStats returns stats of the container. If the container does not"]
            #[doc = " exist, the call returns an error."]
            async fn container_stats(&self, request: tonic::Request<super::ContainerStatsRequest>) -> Result<tonic::Response<super::ContainerStatsResponse>, tonic::Status>;
            #[doc = " ListContainerStats returns stats of all running containers."]
            async fn list_container_stats(&self, request: tonic::Request<super::ListContainerStatsRequest>) -> Result<tonic::Response<super::ListContainerStatsResponse>, tonic::Status>;
            #[doc = " PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not"]
            #[doc = " exist, the call returns an error."]
            async fn pod_sandbox_stats(&self, request: tonic::Request<super::PodSandboxStatsRequest>) -> Result<tonic::Response<super::PodSandboxStatsResponse>, tonic::Status>;
            #[doc = " ListPodSandboxStats returns stats of the pod sandboxes matching a filter."]
            async fn list_pod_sandbox_stats(&self, request: tonic::Request<super::ListPodSandboxStatsRequest>) -> Result<tonic::Response<super::ListPodSandboxStatsResponse>, tonic::Status>;
            #[doc = " UpdateRuntimeConfig updates the runtime configuration based on the given request."]
            async fn update_runtime_config(&self, request: tonic::Request<super::UpdateRuntimeConfigRequest>) -> Result<tonic::Response<super::UpdateRuntimeConfigResponse>, tonic::Status>;
            #[doc = " Status returns the status of the runtime."]
            async fn status(&self, request: tonic::Request<super::StatusRequest>) -> Result<tonic::Response<super::StatusResponse>, tonic::Status>;
        }

        #[doc = " Runtime service defines the public APIs for remote container runtimes"]
        #[derive(Debug)]
        pub struct RuntimeServiceServer<T: RuntimeService> {
            inner: _Inner<T>,
            accept_compression_encodings: EnabledCompressionEncodings,
            send_compression_encodings: EnabledCompressionEncodings,
        }

        struct _Inner<T>   (Arc<T>);

        impl<T: RuntimeService> RuntimeServiceServer<T> {
            pub fn new(inner: T) -> Self { Self::from_arc(Arc::new(inner)) }
            pub fn from_arc(inner: Arc<T>) -> Self {
                let inner = _Inner(inner);
                Self { inner, accept_compression_encodings: Default::default(), send_compression_encodings: Default::default() }
            }
            pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F> where F: tonic::service::Interceptor, { InterceptedService::new(Self::new(inner), interceptor) }
            #[doc = " Enable decompressing requests with the given encoding."]
            #[must_use]
            pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.accept_compression_encodings.enable(encoding);
                self
            }
            #[doc = " Compress responses with the given encoding, if the client supports it."]
            #[must_use]
            pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.send_compression_encodings.enable(encoding);
                self
            }
        }

        impl<T, B> tonic::codegen::Service<http::Request<B>> for RuntimeServiceServer<T> where T: RuntimeService, B: Body + Send + 'static, B::Error: Into<StdError> + Send + 'static, {
            type Response = http::Response<tonic::body::BoxBody>;
            type Error = std::convert::Infallible;
            type Future = BoxFuture<Self::Response, Self::Error>;
            fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> { Poll::Ready(Ok(())) }
            fn call(&mut self, req: http::Request<B>) -> Self::Future {
                let inner = self.inner.clone();
                match req.uri().path() {
                    "/runtime.v1alpha2.RuntimeService/Version" => {
                        #[allow(non_camel_case_types)]
                        struct VersionSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::VersionRequest> for VersionSvc<T> {
                            type Response = super::VersionResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::VersionRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).version(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = VersionSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/RunPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct RunPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RunPodSandboxRequest> for RunPodSandboxSvc<T> {
                            type Response = super::RunPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RunPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).run_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RunPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/StopPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct StopPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StopPodSandboxRequest> for StopPodSandboxSvc<T> {
                            type Response = super::StopPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StopPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).stop_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StopPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/RemovePodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct RemovePodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RemovePodSandboxRequest> for RemovePodSandboxSvc<T> {
                            type Response = super::RemovePodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemovePodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemovePodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/PodSandboxStatus" => {
                        #[allow(non_camel_case_types)]
                        struct PodSandboxStatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PodSandboxStatusRequest> for PodSandboxStatusSvc<T> {
                            type Response = super::PodSandboxStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PodSandboxStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pod_sandbox_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PodSandboxStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ListPodSandbox" => {
                        #[allow(non_camel_case_types)]
                        struct ListPodSandboxSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListPodSandboxRequest> for ListPodSandboxSvc<T> {
                            type Response = super::ListPodSandboxResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListPodSandboxRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_pod_sandbox(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListPodSandboxSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/CreateContainer" => {
                        #[allow(non_camel_case_types)]
                        struct CreateContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::CreateContainerRequest> for CreateContainerSvc<T> {
                            type Response = super::CreateContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::CreateContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).create_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = CreateContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/StartContainer" => {
                        #[allow(non_camel_case_types)]
                        struct StartContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StartContainerRequest> for StartContainerSvc<T> {
                            type Response = super::StartContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StartContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).start_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StartContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/StopContainer" => {
                        #[allow(non_camel_case_types)]
                        struct StopContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StopContainerRequest> for StopContainerSvc<T> {
                            type Response = super::StopContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StopContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).stop_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StopContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/RemoveContainer" => {
                        #[allow(non_camel_case_types)]
                        struct RemoveContainerSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::RemoveContainerRequest> for RemoveContainerSvc<T> {
                            type Response = super::RemoveContainerResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemoveContainerRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_container(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemoveContainerSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ListContainers" => {
                        #[allow(non_camel_case_types)]
                        struct ListContainersSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListContainersRequest> for ListContainersSvc<T> {
                            type Response = super::ListContainersResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListContainersRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_containers(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListContainersSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ContainerStatus" => {
                        #[allow(non_camel_case_types)]
                        struct ContainerStatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ContainerStatusRequest> for ContainerStatusSvc<T> {
                            type Response = super::ContainerStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ContainerStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).container_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ContainerStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/UpdateContainerResources" => {
                        #[allow(non_camel_case_types)]
                        struct UpdateContainerResourcesSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::UpdateContainerResourcesRequest> for UpdateContainerResourcesSvc<T> {
                            type Response = super::UpdateContainerResourcesResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::UpdateContainerResourcesRequest, >) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).update_container_resources(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = UpdateContainerResourcesSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ReopenContainerLog" => {
                        #[allow(non_camel_case_types)]
                        struct ReopenContainerLogSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ReopenContainerLogRequest> for ReopenContainerLogSvc<T> {
                            type Response = super::ReopenContainerLogResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ReopenContainerLogRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).reopen_container_log(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ReopenContainerLogSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ExecSync" => {
                        #[allow(non_camel_case_types)]
                        struct ExecSyncSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ExecSyncRequest> for ExecSyncSvc<T> {
                            type Response = super::ExecSyncResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ExecSyncRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).exec_sync(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ExecSyncSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/Exec" => {
                        #[allow(non_camel_case_types)]
                        struct ExecSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ExecRequest> for ExecSvc<T> {
                            type Response = super::ExecResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ExecRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).exec(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ExecSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/Attach" => {
                        #[allow(non_camel_case_types)]
                        struct AttachSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::AttachRequest> for AttachSvc<T> {
                            type Response = super::AttachResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::AttachRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).attach(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = AttachSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/PortForward" => {
                        #[allow(non_camel_case_types)]
                        struct PortForwardSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PortForwardRequest> for PortForwardSvc<T> {
                            type Response = super::PortForwardResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PortForwardRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).port_forward(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PortForwardSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ContainerStats" => {
                        #[allow(non_camel_case_types)]
                        struct ContainerStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ContainerStatsRequest> for ContainerStatsSvc<T> {
                            type Response = super::ContainerStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ContainerStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).container_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ContainerStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ListContainerStats" => {
                        #[allow(non_camel_case_types)]
                        struct ListContainerStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListContainerStatsRequest> for ListContainerStatsSvc<T> {
                            type Response = super::ListContainerStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListContainerStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_container_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListContainerStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/PodSandboxStats" => {
                        #[allow(non_camel_case_types)]
                        struct PodSandboxStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::PodSandboxStatsRequest> for PodSandboxStatsSvc<T> {
                            type Response = super::PodSandboxStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PodSandboxStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pod_sandbox_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PodSandboxStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/ListPodSandboxStats" => {
                        #[allow(non_camel_case_types)]
                        struct ListPodSandboxStatsSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::ListPodSandboxStatsRequest> for ListPodSandboxStatsSvc<T> {
                            type Response = super::ListPodSandboxStatsResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListPodSandboxStatsRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_pod_sandbox_stats(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListPodSandboxStatsSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/UpdateRuntimeConfig" => {
                        #[allow(non_camel_case_types)]
                        struct UpdateRuntimeConfigSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::UpdateRuntimeConfigRequest> for UpdateRuntimeConfigSvc<T> {
                            type Response = super::UpdateRuntimeConfigResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::UpdateRuntimeConfigRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).update_runtime_config(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = UpdateRuntimeConfigSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.RuntimeService/Status" => {
                        #[allow(non_camel_case_types)]
                        struct StatusSvc<T: RuntimeService>   (pub Arc<T>);
                        impl<T: RuntimeService, > tonic::server::UnaryService<super::StatusRequest> for StatusSvc<T> {
                            type Response = super::StatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::StatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = StatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    _ => { Box::pin(async move { Ok(http::Response::builder().status(200).header("grpc-status", "12").header("content-type", "application/grpc").body(empty_body()).unwrap()) }) }
                }
            }
        }

        impl<T: RuntimeService> Clone for RuntimeServiceServer<T> {
            fn clone(&self) -> Self {
                let inner = self.inner.clone();
                Self { inner, accept_compression_encodings: self.accept_compression_encodings, send_compression_encodings: self.send_compression_encodings }
            }
        }

        impl<T: RuntimeService> Clone for _Inner<T> { fn clone(&self) -> Self { Self(self.0.clone()) } }

        impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { f.write_fmt(IntellijRustDollarCrate::format_args!("{:?}", self.0)) } }

        impl<T: RuntimeService> tonic::server::NamedService for RuntimeServiceServer<T> { const NAME: &'static str = "runtime.v1alpha2.RuntimeService"; }
    }

    #[doc = " Generated server implementations."]
    pub mod image_service_server {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]

        use tonic::codegen::*;

        #[doc = "Generated trait containing gRPC methods that should be implemented for use with ImageServiceServer."]
        #[async_trait]
        pub trait ImageService: Send + Sync + 'static {
            #[doc = " ListImages lists existing images."]
            async fn list_images(&self, request: tonic::Request<super::ListImagesRequest>) -> Result<tonic::Response<super::ListImagesResponse>, tonic::Status>;
            #[doc = " ImageStatus returns the status of the image. If the image is not"]
            #[doc = " present, returns a response with ImageStatusResponse.Image set to"]
            #[doc = " nil."]
            async fn image_status(&self, request: tonic::Request<super::ImageStatusRequest>) -> Result<tonic::Response<super::ImageStatusResponse>, tonic::Status>;
            #[doc = " PullImage pulls an image with authentication config."]
            async fn pull_image(&self, request: tonic::Request<super::PullImageRequest>) -> Result<tonic::Response<super::PullImageResponse>, tonic::Status>;
            #[doc = " RemoveImage removes the image."]
            #[doc = " This call is idempotent, and must not return an error if the image has"]
            #[doc = " already been removed."]
            async fn remove_image(&self, request: tonic::Request<super::RemoveImageRequest>) -> Result<tonic::Response<super::RemoveImageResponse>, tonic::Status>;
            #[doc = " ImageFSInfo returns information of the filesystem that is used to store images."]
            async fn image_fs_info(&self, request: tonic::Request<super::ImageFsInfoRequest>) -> Result<tonic::Response<super::ImageFsInfoResponse>, tonic::Status>;
        }

        #[doc = " ImageService defines the public APIs for managing images."]
        #[derive(Debug)]
        pub struct ImageServiceServer<T: ImageService> {
            inner: _Inner<T>,
            accept_compression_encodings: EnabledCompressionEncodings,
            send_compression_encodings: EnabledCompressionEncodings,
        }

        struct _Inner<T>   (Arc<T>);

        impl<T: ImageService> ImageServiceServer<T> {
            pub fn new(inner: T) -> Self { Self::from_arc(Arc::new(inner)) }
            pub fn from_arc(inner: Arc<T>) -> Self {
                let inner = _Inner(inner);
                Self { inner, accept_compression_encodings: Default::default(), send_compression_encodings: Default::default() }
            }
            pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F> where F: tonic::service::Interceptor, { InterceptedService::new(Self::new(inner), interceptor) }
            #[doc = " Enable decompressing requests with the given encoding."]
            #[must_use]
            pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.accept_compression_encodings.enable(encoding);
                self
            }
            #[doc = " Compress responses with the given encoding, if the client supports it."]
            #[must_use]
            pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.send_compression_encodings.enable(encoding);
                self
            }
        }

        impl<T, B> tonic::codegen::Service<http::Request<B>> for ImageServiceServer<T> where T: ImageService, B: Body + Send + 'static, B::Error: Into<StdError> + Send + 'static, {
            type Response = http::Response<tonic::body::BoxBody>;
            type Error = std::convert::Infallible;
            type Future = BoxFuture<Self::Response, Self::Error>;
            fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> { Poll::Ready(Ok(())) }
            fn call(&mut self, req: http::Request<B>) -> Self::Future {
                let inner = self.inner.clone();
                match req.uri().path() {
                    "/runtime.v1alpha2.ImageService/ListImages" => {
                        #[allow(non_camel_case_types)]
                        struct ListImagesSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ListImagesRequest> for ListImagesSvc<T> {
                            type Response = super::ListImagesResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ListImagesRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).list_images(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ListImagesSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.ImageService/ImageStatus" => {
                        #[allow(non_camel_case_types)]
                        struct ImageStatusSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ImageStatusRequest> for ImageStatusSvc<T> {
                            type Response = super::ImageStatusResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ImageStatusRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).image_status(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ImageStatusSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.ImageService/PullImage" => {
                        #[allow(non_camel_case_types)]
                        struct PullImageSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::PullImageRequest> for PullImageSvc<T> {
                            type Response = super::PullImageResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::PullImageRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).pull_image(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = PullImageSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.ImageService/RemoveImage" => {
                        #[allow(non_camel_case_types)]
                        struct RemoveImageSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::RemoveImageRequest> for RemoveImageSvc<T> {
                            type Response = super::RemoveImageResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::RemoveImageRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).remove_image(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = RemoveImageSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/runtime.v1alpha2.ImageService/ImageFsInfo" => {
                        #[allow(non_camel_case_types)]
                        struct ImageFsInfoSvc<T: ImageService>   (pub Arc<T>);
                        impl<T: ImageService, > tonic::server::UnaryService<super::ImageFsInfoRequest> for ImageFsInfoSvc<T> {
                            type Response = super::ImageFsInfoResponse;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status, >;
                            fn call(&mut self, request: tonic::Request<super::ImageFsInfoRequest>) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { (*inner).image_fs_info(request).await };
                                Box::pin(fut)
                            }
                        }
                        let accept_compression_encodings = self.accept_compression_encodings;
                        let send_compression_encodings = self.send_compression_encodings;
                        let inner = self.inner.clone();
                        let fut = async move {
                            let inner = inner.0;
                            let method = ImageFsInfoSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = tonic::server::Grpc::new(codec).apply_compression_config(accept_compression_encodings, send_compression_encodings);
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    _ => { Box::pin(async move { Ok(http::Response::builder().status(200).header("grpc-status", "12").header("content-type", "application/grpc").body(empty_body()).unwrap()) }) }
                }
            }
        }

        impl<T: ImageService> Clone for ImageServiceServer<T> {
            fn clone(&self) -> Self {
                let inner = self.inner.clone();
                Self { inner, accept_compression_encodings: self.accept_compression_encodings, send_compression_encodings: self.send_compression_encodings }
            }
        }

        impl<T: ImageService> Clone for _Inner<T> { fn clone(&self) -> Self { Self(self.0.clone()) } }

        impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { f.write_fmt(IntellijRustDollarCrate::format_args!("{:?}", self.0)) } }

        impl<T: ImageService> tonic::server::NamedService for ImageServiceServer<T> { const NAME: &'static str = "runtime.v1alpha2.ImageService"; }
    }

    #[tonic::async_trait]
    impl super::ImageService_v1alpha2 for super::Square {
        #[doc = " ListImages lists existing images."]
        async fn list_images(&self, request: tonic::Request<ListImagesRequest>) -> Result<tonic::Response<ListImagesResponse>, tonic::Status> { self.list_images(request).await }
        #[doc = " ImageStatus returns the status of the image. If the image is not"]
        #[doc = " present, returns a response with ImageStatusResponse.Image set to"]
        #[doc = " nil."]
        async fn image_status(&self, request: tonic::Request<ImageStatusRequest>) -> Result<tonic::Response<ImageStatusResponse>, tonic::Status> { self.image_status(request).await }
        #[doc = " PullImage pulls an image with authentication config."]
        async fn pull_image(&self, request: tonic::Request<PullImageRequest>) -> Result<tonic::Response<PullImageResponse>, tonic::Status> { self.pull_image(request).await }
        #[doc = " RemoveImage removes the image."]
        #[doc = " This call is idempotent, and must not return an error if the image has"]
        #[doc = " already been removed."]
        async fn remove_image(&self, request: tonic::Request<RemoveImageRequest>) -> Result<tonic::Response<RemoveImageResponse>, tonic::Status> { self.remove_image(request).await }
        #[doc = " ImageFSInfo returns information of the filesystem that is used to store images."]
        async fn image_fs_info(&self, request: tonic::Request<ImageFsInfoRequest>) -> Result<tonic::Response<ImageFsInfoResponse>, tonic::Status> { self.image_fs_info(request).await }
    }
}
use image_service_server::ImageService   as ImageService_v1alpha2;
```